// Generated by `wit-bindgen` 0.46.0. DO NOT EDIT!
// Options used:
//   * type_section_suffix: "rust-wasip3-0.1.1+wasi-0.3.0-rc-2025-08-15-from-crates-io"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod wasi {
    pub mod cli {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod environment {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[allow(unused_unsafe, clippy::all)]
            /// Get the POSIX-style environment variables.
            ///
            /// Each environment variable is provided as a pair of string variable names
            /// and string value.
            ///
            /// Morally, these are a value import, but until value imports are available
            /// in the component model, this import function should return the same
            /// values each time it is called.
            #[allow(async_fn_in_trait)]
            pub fn get_environment() -> _rt::Vec<(_rt::String, _rt::String)> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:cli/environment@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "get-environment"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import1(ptr0);
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base10 = l2;
                    let len10 = l3;
                    let mut result10 = _rt::Vec::with_capacity(len10);
                    for i in 0..len10 {
                        let base = base10
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        let e10 = {
                            let l4 = *base.add(0).cast::<*mut u8>();
                            let l5 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len6 = l5;
                            let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                            let l7 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l8 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len9 = l8;
                            let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                            (_rt::string_lift(bytes6), _rt::string_lift(bytes9))
                        };
                        result10.push(e10);
                    }
                    _rt::cabi_dealloc(
                        base10,
                        len10 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result11 = result10;
                    result11
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get the POSIX-style arguments to the program.
            #[allow(async_fn_in_trait)]
            pub fn get_arguments() -> _rt::Vec<_rt::String> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:cli/environment@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "get-arguments"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import1(ptr0);
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base7 = l2;
                    let len7 = l3;
                    let mut result7 = _rt::Vec::with_capacity(len7);
                    for i in 0..len7 {
                        let base = base7
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        let e7 = {
                            let l4 = *base.add(0).cast::<*mut u8>();
                            let l5 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len6 = l5;
                            let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                            _rt::string_lift(bytes6)
                        };
                        result7.push(e7);
                    }
                    _rt::cabi_dealloc(
                        base7,
                        len7 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result8 = result7;
                    result8
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Return a path that programs should use as their initial current working
            /// directory, interpreting `.` as shorthand for this.
            #[allow(async_fn_in_trait)]
            pub fn get_initial_cwd() -> Option<_rt::String> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 3 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 3
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:cli/environment@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "get-initial-cwd"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import1(ptr0);
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result6 = match l2 {
                        0 => None,
                        1 => {
                            let e = {
                                let l3 = *ptr0
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l4 = *ptr0
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len5 = l4;
                                let bytes5 = _rt::Vec::from_raw_parts(
                                    l3.cast(),
                                    len5,
                                    len5,
                                );
                                _rt::string_lift(bytes5)
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result6
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod exit {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            #[allow(unused_unsafe, clippy::all)]
            /// Exit the current instance and any linked instances.
            #[allow(async_fn_in_trait)]
            pub fn exit(status: Result<(), ()>) -> () {
                unsafe {
                    let result0 = match status {
                        Ok(_) => 0i32,
                        Err(_) => 1i32,
                    };
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:cli/exit@0.3.0-rc-2025-08-15")]
                    unsafe extern "C" {
                        #[link_name = "exit"]
                        fn wit_import1(_: i32);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: i32) {
                        unreachable!()
                    }
                    wit_import1(result0);
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod stdin {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn get_stdin() -> wit_bindgen::rt::async_support::StreamReader<u8> {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:cli/stdin@0.3.0-rc-2025-08-15")]
                    unsafe extern "C" {
                        #[link_name = "get-stdin"]
                        fn wit_import0() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import0();
                    wit_bindgen::rt::async_support::StreamReader::new(
                        ret as u32,
                        &super::super::super::wit_stream::vtable0::VTABLE,
                    )
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod stdout {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn set_stdout(
                data: wit_bindgen::rt::async_support::StreamReader<u8>,
            ) -> () {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:cli/stdout@0.3.0-rc-2025-08-15")]
                    unsafe extern "C" {
                        #[link_name = "set-stdout"]
                        fn wit_import0(_: i32);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0(_: i32) {
                        unreachable!()
                    }
                    wit_import0((&data).take_handle() as i32);
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod stderr {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn set_stderr(
                data: wit_bindgen::rt::async_support::StreamReader<u8>,
            ) -> () {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:cli/stderr@0.3.0-rc-2025-08-15")]
                    unsafe extern "C" {
                        #[link_name = "set-stderr"]
                        fn wit_import0(_: i32);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0(_: i32) {
                        unreachable!()
                    }
                    wit_import0((&data).take_handle() as i32);
                }
            }
        }
        /// Terminal input.
        ///
        /// In the future, this may include functions for disabling echoing,
        /// disabling input buffering so that keyboard events are sent through
        /// immediately, querying supported features, and so on.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod terminal_input {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            /// The input side of a terminal.
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct TerminalInput {
                handle: _rt::Resource<TerminalInput>,
            }
            impl TerminalInput {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for TerminalInput {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:cli/terminal-input@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "[resource-drop]terminal-input"]
                        fn drop(_: i32);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn drop(_: i32) {
                        unreachable!()
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
        }
        /// Terminal output.
        ///
        /// In the future, this may include functions for querying the terminal
        /// size, being notified of terminal size changes, querying supported
        /// features, and so on.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod terminal_output {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            /// The output side of a terminal.
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct TerminalOutput {
                handle: _rt::Resource<TerminalOutput>,
            }
            impl TerminalOutput {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for TerminalOutput {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:cli/terminal-output@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "[resource-drop]terminal-output"]
                        fn drop(_: i32);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn drop(_: i32) {
                        unreachable!()
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
        }
        /// An interface providing an optional `terminal-input` for stdin as a
        /// link-time authority.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod terminal_stdin {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type TerminalInput = super::super::super::wasi::cli::terminal_input::TerminalInput;
            #[allow(unused_unsafe, clippy::all)]
            /// If stdin is connected to a terminal, return a `terminal-input` handle
            /// allowing further interaction with it.
            #[allow(async_fn_in_trait)]
            pub fn get_terminal_stdin() -> Option<TerminalInput> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:cli/terminal-stdin@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "get-terminal-stdin"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import1(ptr0);
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result4 = match l2 {
                        0 => None,
                        1 => {
                            let e = {
                                let l3 = *ptr0.add(4).cast::<i32>();
                                super::super::super::wasi::cli::terminal_input::TerminalInput::from_handle(
                                    l3 as u32,
                                )
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result4
                }
            }
        }
        /// An interface providing an optional `terminal-output` for stdout as a
        /// link-time authority.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod terminal_stdout {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type TerminalOutput = super::super::super::wasi::cli::terminal_output::TerminalOutput;
            #[allow(unused_unsafe, clippy::all)]
            /// If stdout is connected to a terminal, return a `terminal-output` handle
            /// allowing further interaction with it.
            #[allow(async_fn_in_trait)]
            pub fn get_terminal_stdout() -> Option<TerminalOutput> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:cli/terminal-stdout@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "get-terminal-stdout"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import1(ptr0);
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result4 = match l2 {
                        0 => None,
                        1 => {
                            let e = {
                                let l3 = *ptr0.add(4).cast::<i32>();
                                super::super::super::wasi::cli::terminal_output::TerminalOutput::from_handle(
                                    l3 as u32,
                                )
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result4
                }
            }
        }
        /// An interface providing an optional `terminal-output` for stderr as a
        /// link-time authority.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod terminal_stderr {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type TerminalOutput = super::super::super::wasi::cli::terminal_output::TerminalOutput;
            #[allow(unused_unsafe, clippy::all)]
            /// If stderr is connected to a terminal, return a `terminal-output` handle
            /// allowing further interaction with it.
            #[allow(async_fn_in_trait)]
            pub fn get_terminal_stderr() -> Option<TerminalOutput> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:cli/terminal-stderr@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "get-terminal-stderr"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import1(ptr0);
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result4 = match l2 {
                        0 => None,
                        1 => {
                            let e = {
                                let l3 = *ptr0.add(4).cast::<i32>();
                                super::super::super::wasi::cli::terminal_output::TerminalOutput::from_handle(
                                    l3 as u32,
                                )
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result4
                }
            }
        }
    }
    pub mod clocks {
        /// WASI Monotonic Clock is a clock API intended to let users measure elapsed
        /// time.
        ///
        /// It is intended to be portable at least between Unix-family platforms and
        /// Windows.
        ///
        /// A monotonic clock is a clock which has an unspecified initial value, and
        /// successive reads of the clock will produce non-decreasing values.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod monotonic_clock {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            /// An instant in time, in nanoseconds. An instant is relative to an
            /// unspecified initial value, and can only be compared to instances from
            /// the same monotonic-clock.
            pub type Instant = u64;
            /// A duration of time, in nanoseconds.
            pub type Duration = u64;
            #[allow(unused_unsafe, clippy::all)]
            /// Read the current value of the clock.
            ///
            /// The clock is monotonic, therefore calling this function repeatedly will
            /// produce a sequence of non-decreasing values.
            #[allow(async_fn_in_trait)]
            pub fn now() -> Instant {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "now"]
                        fn wit_import0() -> i64;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0() -> i64 {
                        unreachable!()
                    }
                    let ret = wit_import0();
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Query the resolution of the clock. Returns the duration of time
            /// corresponding to a clock tick.
            #[allow(async_fn_in_trait)]
            pub fn get_resolution() -> Duration {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "get-resolution"]
                        fn wit_import0() -> i64;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0() -> i64 {
                        unreachable!()
                    }
                    let ret = wit_import0();
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Wait until the specified instant has occurred.
            #[allow(async_fn_in_trait)]
            pub async fn wait_until(when: Instant) -> () {
                unsafe {
                    use wit_bindgen::rt::async_support::Subtask as _Subtask;
                    struct _MySubtask<'a> {
                        _unused: &'a (),
                    }
                    #[allow(unused_parens)]
                    unsafe impl<'a> _Subtask for _MySubtask<'a> {
                        type Params = (Instant,);
                        type Results = ();
                        type ParamsLower = (i64,);
                        const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                            ::core::alloc::Layout::from_size_align_unchecked(0, 1)
                        };
                        const RESULTS_OFFSET: usize = 0;
                        unsafe fn call_import(
                            _params: Self::ParamsLower,
                            _results: *mut u8,
                        ) -> u32 {
                            #[cfg(target_arch = "wasm32")]
                            #[link(
                                wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2025-08-15"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[async-lower][async]wait-until"]
                                fn call(_: i64) -> i32;
                            }
                            #[cfg(not(target_arch = "wasm32"))]
                            unsafe extern "C" fn call(_: i64) -> i32 {
                                unreachable!()
                            }
                            unsafe { call(_params.0) as u32 }
                        }
                        unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                            unsafe {}
                        }
                        unsafe fn params_dealloc_lists_and_own(
                            _params: Self::ParamsLower,
                        ) {
                            unsafe {}
                        }
                        unsafe fn params_lower(
                            (_lower0,): Self::Params,
                            _ptr: *mut u8,
                        ) -> Self::ParamsLower {
                            unsafe { (_rt::as_i64(_lower0),) }
                        }
                        unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {}
                    }
                    _MySubtask::call((when,)).await
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Wait for the specified duration has elapsed.
            #[allow(async_fn_in_trait)]
            pub async fn wait_for(how_long: Duration) -> () {
                unsafe {
                    use wit_bindgen::rt::async_support::Subtask as _Subtask;
                    struct _MySubtask<'a> {
                        _unused: &'a (),
                    }
                    #[allow(unused_parens)]
                    unsafe impl<'a> _Subtask for _MySubtask<'a> {
                        type Params = (Duration,);
                        type Results = ();
                        type ParamsLower = (i64,);
                        const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                            ::core::alloc::Layout::from_size_align_unchecked(0, 1)
                        };
                        const RESULTS_OFFSET: usize = 0;
                        unsafe fn call_import(
                            _params: Self::ParamsLower,
                            _results: *mut u8,
                        ) -> u32 {
                            #[cfg(target_arch = "wasm32")]
                            #[link(
                                wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2025-08-15"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[async-lower][async]wait-for"]
                                fn call(_: i64) -> i32;
                            }
                            #[cfg(not(target_arch = "wasm32"))]
                            unsafe extern "C" fn call(_: i64) -> i32 {
                                unreachable!()
                            }
                            unsafe { call(_params.0) as u32 }
                        }
                        unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                            unsafe {}
                        }
                        unsafe fn params_dealloc_lists_and_own(
                            _params: Self::ParamsLower,
                        ) {
                            unsafe {}
                        }
                        unsafe fn params_lower(
                            (_lower0,): Self::Params,
                            _ptr: *mut u8,
                        ) -> Self::ParamsLower {
                            unsafe { (_rt::as_i64(_lower0),) }
                        }
                        unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {}
                    }
                    _MySubtask::call((how_long,)).await
                }
            }
        }
        /// WASI Wall Clock is a clock API intended to let users query the current
        /// time. The name "wall" makes an analogy to a "clock on the wall", which
        /// is not necessarily monotonic as it may be reset.
        ///
        /// It is intended to be portable at least between Unix-family platforms and
        /// Windows.
        ///
        /// A wall clock is a clock which measures the date and time according to
        /// some external reference.
        ///
        /// External references may be reset, so this clock is not necessarily
        /// monotonic, making it unsuitable for measuring elapsed time.
        ///
        /// It is intended for reporting the current date and time for humans.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod wall_clock {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            /// A time and date in seconds plus nanoseconds.
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Datetime {
                pub seconds: u64,
                pub nanoseconds: u32,
            }
            impl ::core::fmt::Debug for Datetime {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Datetime")
                        .field("seconds", &self.seconds)
                        .field("nanoseconds", &self.nanoseconds)
                        .finish()
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Read the current value of the clock.
            ///
            /// This clock is not monotonic, therefore calling this function repeatedly
            /// will not necessarily produce a sequence of non-decreasing values.
            ///
            /// The returned timestamps represent the number of seconds since
            /// 1970-01-01T00:00:00Z, also known as [POSIX's Seconds Since the Epoch],
            /// also known as [Unix Time].
            ///
            /// The nanoseconds field of the output is always less than 1000000000.
            ///
            /// [POSIX's Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16
            /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time
            #[allow(async_fn_in_trait)]
            pub fn now() -> Datetime {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:clocks/wall-clock@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "now"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import1(ptr0);
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i32>();
                    let result4 = Datetime {
                        seconds: l2 as u64,
                        nanoseconds: l3 as u32,
                    };
                    result4
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Query the resolution of the clock.
            ///
            /// The nanoseconds field of the output is always less than 1000000000.
            #[allow(async_fn_in_trait)]
            pub fn get_resolution() -> Datetime {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:clocks/wall-clock@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "get-resolution"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import1(ptr0);
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i32>();
                    let result4 = Datetime {
                        seconds: l2 as u64,
                        nanoseconds: l3 as u32,
                    };
                    result4
                }
            }
        }
    }
    pub mod filesystem {
        /// WASI filesystem is a filesystem API primarily intended to let users run WASI
        /// programs that access their files on their existing filesystems, without
        /// significant overhead.
        ///
        /// It is intended to be roughly portable between Unix-family platforms and
        /// Windows, though it does not hide many of the major differences.
        ///
        /// Paths are passed as interface-type `string`s, meaning they must consist of
        /// a sequence of Unicode Scalar Values (USVs). Some filesystems may contain
        /// paths which are not accessible by this API.
        ///
        /// The directory separator in WASI is always the forward-slash (`/`).
        ///
        /// All paths in WASI are relative paths, and are interpreted relative to a
        /// `descriptor` referring to a base directory. If a `path` argument to any WASI
        /// function starts with `/`, or if any step of resolving a `path`, including
        /// `..` and symbolic link steps, reaches a directory outside of the base
        /// directory, or reaches a symlink to an absolute or rooted path in the
        /// underlying filesystem, the function fails with `error-code::not-permitted`.
        ///
        /// For more information about WASI path resolution and sandboxing, see
        /// [WASI filesystem path resolution].
        ///
        /// [WASI filesystem path resolution]: https://github.com/WebAssembly/wasi-filesystem/blob/main/path-resolution.md
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Datetime = super::super::super::wasi::clocks::wall_clock::Datetime;
            /// File size or length of a region within a file.
            pub type Filesize = u64;
            /// The type of a filesystem object referenced by a descriptor.
            ///
            /// Note: This was called `filetype` in earlier versions of WASI.
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum DescriptorType {
                /// The type of the descriptor or file is unknown or is different from
                /// any of the other types specified.
                Unknown,
                /// The descriptor refers to a block device inode.
                BlockDevice,
                /// The descriptor refers to a character device inode.
                CharacterDevice,
                /// The descriptor refers to a directory inode.
                Directory,
                /// The descriptor refers to a named pipe.
                Fifo,
                /// The file refers to a symbolic link inode.
                SymbolicLink,
                /// The descriptor refers to a regular file inode.
                RegularFile,
                /// The descriptor refers to a socket.
                Socket,
            }
            impl ::core::fmt::Debug for DescriptorType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        DescriptorType::Unknown => {
                            f.debug_tuple("DescriptorType::Unknown").finish()
                        }
                        DescriptorType::BlockDevice => {
                            f.debug_tuple("DescriptorType::BlockDevice").finish()
                        }
                        DescriptorType::CharacterDevice => {
                            f.debug_tuple("DescriptorType::CharacterDevice").finish()
                        }
                        DescriptorType::Directory => {
                            f.debug_tuple("DescriptorType::Directory").finish()
                        }
                        DescriptorType::Fifo => {
                            f.debug_tuple("DescriptorType::Fifo").finish()
                        }
                        DescriptorType::SymbolicLink => {
                            f.debug_tuple("DescriptorType::SymbolicLink").finish()
                        }
                        DescriptorType::RegularFile => {
                            f.debug_tuple("DescriptorType::RegularFile").finish()
                        }
                        DescriptorType::Socket => {
                            f.debug_tuple("DescriptorType::Socket").finish()
                        }
                    }
                }
            }
            impl DescriptorType {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> DescriptorType {
                    if !cfg!(debug_assertions) {
                        return unsafe { ::core::mem::transmute(val) };
                    }
                    match val {
                        0 => DescriptorType::Unknown,
                        1 => DescriptorType::BlockDevice,
                        2 => DescriptorType::CharacterDevice,
                        3 => DescriptorType::Directory,
                        4 => DescriptorType::Fifo,
                        5 => DescriptorType::SymbolicLink,
                        6 => DescriptorType::RegularFile,
                        7 => DescriptorType::Socket,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            wit_bindgen::rt::bitflags::bitflags! {
                #[doc = " Descriptor flags."] #[doc = ""] #[doc =
                " Note: This was called `fdflags` in earlier versions of WASI."]
                #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)] pub
                struct DescriptorFlags : u8 { #[doc = " Read mode: Data can be read."]
                const READ = 1 << 0; #[doc = " Write mode: Data can be written to."]
                const WRITE = 1 << 1; #[doc =
                " Request that writes be performed according to synchronized I/O file"]
                #[doc =
                " integrity completion. The data stored in the file and the file's"]
                #[doc =
                " metadata are synchronized. This is similar to `O_SYNC` in POSIX."]
                #[doc = ""] #[doc =
                " The precise semantics of this operation have not yet been defined for"]
                #[doc =
                " WASI. At this time, it should be interpreted as a request, and not a"]
                #[doc = " requirement."] const FILE_INTEGRITY_SYNC = 1 << 2; #[doc =
                " Request that writes be performed according to synchronized I/O data"]
                #[doc = " integrity completion. Only the data stored in the file is"]
                #[doc = " synchronized. This is similar to `O_DSYNC` in POSIX."] #[doc =
                ""] #[doc =
                " The precise semantics of this operation have not yet been defined for"]
                #[doc =
                " WASI. At this time, it should be interpreted as a request, and not a"]
                #[doc = " requirement."] const DATA_INTEGRITY_SYNC = 1 << 3; #[doc =
                " Requests that reads be performed at the same level of integrity"] #[doc
                = " requested for writes. This is similar to `O_RSYNC` in POSIX."] #[doc
                = ""] #[doc =
                " The precise semantics of this operation have not yet been defined for"]
                #[doc =
                " WASI. At this time, it should be interpreted as a request, and not a"]
                #[doc = " requirement."] const REQUESTED_WRITE_SYNC = 1 << 4; #[doc =
                " Mutating directories mode: Directory contents may be mutated."] #[doc =
                ""] #[doc =
                " When this flag is unset on a descriptor, operations using the"] #[doc =
                " descriptor which would create, rename, delete, modify the data or"]
                #[doc =
                " metadata of filesystem objects, or obtain another handle which"] #[doc
                =
                " would permit any of those, shall fail with `error-code::read-only` if"]
                #[doc = " they would otherwise succeed."] #[doc = ""] #[doc =
                " This may only be set on directories."] const MUTATE_DIRECTORY = 1 << 5;
                }
            }
            wit_bindgen::rt::bitflags::bitflags! {
                #[doc = " Flags determining the method of how paths are resolved."]
                #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)] pub
                struct PathFlags : u8 { #[doc =
                " As long as the resolved path corresponds to a symbolic link, it is"]
                #[doc = " expanded."] const SYMLINK_FOLLOW = 1 << 0; }
            }
            wit_bindgen::rt::bitflags::bitflags! {
                #[doc = " Open flags used by `open-at`."] #[derive(PartialEq, Eq,
                PartialOrd, Ord, Hash, Debug, Clone, Copy)] pub struct OpenFlags : u8 {
                #[doc =
                " Create file if it does not exist, similar to `O_CREAT` in POSIX."]
                const CREATE = 1 << 0; #[doc =
                " Fail if not a directory, similar to `O_DIRECTORY` in POSIX."] const
                DIRECTORY = 1 << 1; #[doc =
                " Fail if file already exists, similar to `O_EXCL` in POSIX."] const
                EXCLUSIVE = 1 << 2; #[doc =
                " Truncate file to size 0, similar to `O_TRUNC` in POSIX."] const
                TRUNCATE = 1 << 3; }
            }
            /// Number of hard links to an inode.
            pub type LinkCount = u64;
            /// File attributes.
            ///
            /// Note: This was called `filestat` in earlier versions of WASI.
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct DescriptorStat {
                /// File type.
                pub type_: DescriptorType,
                /// Number of hard links to the file.
                pub link_count: LinkCount,
                /// For regular files, the file size in bytes. For symbolic links, the
                /// length in bytes of the pathname contained in the symbolic link.
                pub size: Filesize,
                /// Last data access timestamp.
                ///
                /// If the `option` is none, the platform doesn't maintain an access
                /// timestamp for this file.
                pub data_access_timestamp: Option<Datetime>,
                /// Last data modification timestamp.
                ///
                /// If the `option` is none, the platform doesn't maintain a
                /// modification timestamp for this file.
                pub data_modification_timestamp: Option<Datetime>,
                /// Last file status-change timestamp.
                ///
                /// If the `option` is none, the platform doesn't maintain a
                /// status-change timestamp for this file.
                pub status_change_timestamp: Option<Datetime>,
            }
            impl ::core::fmt::Debug for DescriptorStat {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("DescriptorStat")
                        .field("type", &self.type_)
                        .field("link-count", &self.link_count)
                        .field("size", &self.size)
                        .field("data-access-timestamp", &self.data_access_timestamp)
                        .field(
                            "data-modification-timestamp",
                            &self.data_modification_timestamp,
                        )
                        .field("status-change-timestamp", &self.status_change_timestamp)
                        .finish()
                }
            }
            /// When setting a timestamp, this gives the value to set it to.
            #[derive(Clone, Copy)]
            pub enum NewTimestamp {
                /// Leave the timestamp set to its previous value.
                NoChange,
                /// Set the timestamp to the current time of the system clock associated
                /// with the filesystem.
                Now,
                /// Set the timestamp to the given value.
                Timestamp(Datetime),
            }
            impl ::core::fmt::Debug for NewTimestamp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        NewTimestamp::NoChange => {
                            f.debug_tuple("NewTimestamp::NoChange").finish()
                        }
                        NewTimestamp::Now => f.debug_tuple("NewTimestamp::Now").finish(),
                        NewTimestamp::Timestamp(e) => {
                            f.debug_tuple("NewTimestamp::Timestamp").field(e).finish()
                        }
                    }
                }
            }
            /// A directory entry.
            #[derive(Clone)]
            pub struct DirectoryEntry {
                /// The type of the file referred to by this directory entry.
                pub type_: DescriptorType,
                /// The name of the object.
                pub name: _rt::String,
            }
            impl ::core::fmt::Debug for DirectoryEntry {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("DirectoryEntry")
                        .field("type", &self.type_)
                        .field("name", &self.name)
                        .finish()
                }
            }
            /// Error codes returned by functions, similar to `errno` in POSIX.
            /// Not all of these error codes are returned by the functions provided by this
            /// API; some are used in higher-level library layers, and others are provided
            /// merely for alignment with POSIX.
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum ErrorCode {
                /// Permission denied, similar to `EACCES` in POSIX.
                Access,
                /// Connection already in progress, similar to `EALREADY` in POSIX.
                Already,
                /// Bad descriptor, similar to `EBADF` in POSIX.
                BadDescriptor,
                /// Device or resource busy, similar to `EBUSY` in POSIX.
                Busy,
                /// Resource deadlock would occur, similar to `EDEADLK` in POSIX.
                Deadlock,
                /// Storage quota exceeded, similar to `EDQUOT` in POSIX.
                Quota,
                /// File exists, similar to `EEXIST` in POSIX.
                Exist,
                /// File too large, similar to `EFBIG` in POSIX.
                FileTooLarge,
                /// Illegal byte sequence, similar to `EILSEQ` in POSIX.
                IllegalByteSequence,
                /// Operation in progress, similar to `EINPROGRESS` in POSIX.
                InProgress,
                /// Interrupted function, similar to `EINTR` in POSIX.
                Interrupted,
                /// Invalid argument, similar to `EINVAL` in POSIX.
                Invalid,
                /// I/O error, similar to `EIO` in POSIX.
                Io,
                /// Is a directory, similar to `EISDIR` in POSIX.
                IsDirectory,
                /// Too many levels of symbolic links, similar to `ELOOP` in POSIX.
                Loop,
                /// Too many links, similar to `EMLINK` in POSIX.
                TooManyLinks,
                /// Message too large, similar to `EMSGSIZE` in POSIX.
                MessageSize,
                /// Filename too long, similar to `ENAMETOOLONG` in POSIX.
                NameTooLong,
                /// No such device, similar to `ENODEV` in POSIX.
                NoDevice,
                /// No such file or directory, similar to `ENOENT` in POSIX.
                NoEntry,
                /// No locks available, similar to `ENOLCK` in POSIX.
                NoLock,
                /// Not enough space, similar to `ENOMEM` in POSIX.
                InsufficientMemory,
                /// No space left on device, similar to `ENOSPC` in POSIX.
                InsufficientSpace,
                /// Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX.
                NotDirectory,
                /// Directory not empty, similar to `ENOTEMPTY` in POSIX.
                NotEmpty,
                /// State not recoverable, similar to `ENOTRECOVERABLE` in POSIX.
                NotRecoverable,
                /// Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX.
                Unsupported,
                /// Inappropriate I/O control operation, similar to `ENOTTY` in POSIX.
                NoTty,
                /// No such device or address, similar to `ENXIO` in POSIX.
                NoSuchDevice,
                /// Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX.
                Overflow,
                /// Operation not permitted, similar to `EPERM` in POSIX.
                NotPermitted,
                /// Broken pipe, similar to `EPIPE` in POSIX.
                Pipe,
                /// Read-only file system, similar to `EROFS` in POSIX.
                ReadOnly,
                /// Invalid seek, similar to `ESPIPE` in POSIX.
                InvalidSeek,
                /// Text file busy, similar to `ETXTBSY` in POSIX.
                TextFileBusy,
                /// Cross-device link, similar to `EXDEV` in POSIX.
                CrossDevice,
            }
            impl ErrorCode {
                pub fn name(&self) -> &'static str {
                    match self {
                        ErrorCode::Access => "access",
                        ErrorCode::Already => "already",
                        ErrorCode::BadDescriptor => "bad-descriptor",
                        ErrorCode::Busy => "busy",
                        ErrorCode::Deadlock => "deadlock",
                        ErrorCode::Quota => "quota",
                        ErrorCode::Exist => "exist",
                        ErrorCode::FileTooLarge => "file-too-large",
                        ErrorCode::IllegalByteSequence => "illegal-byte-sequence",
                        ErrorCode::InProgress => "in-progress",
                        ErrorCode::Interrupted => "interrupted",
                        ErrorCode::Invalid => "invalid",
                        ErrorCode::Io => "io",
                        ErrorCode::IsDirectory => "is-directory",
                        ErrorCode::Loop => "loop",
                        ErrorCode::TooManyLinks => "too-many-links",
                        ErrorCode::MessageSize => "message-size",
                        ErrorCode::NameTooLong => "name-too-long",
                        ErrorCode::NoDevice => "no-device",
                        ErrorCode::NoEntry => "no-entry",
                        ErrorCode::NoLock => "no-lock",
                        ErrorCode::InsufficientMemory => "insufficient-memory",
                        ErrorCode::InsufficientSpace => "insufficient-space",
                        ErrorCode::NotDirectory => "not-directory",
                        ErrorCode::NotEmpty => "not-empty",
                        ErrorCode::NotRecoverable => "not-recoverable",
                        ErrorCode::Unsupported => "unsupported",
                        ErrorCode::NoTty => "no-tty",
                        ErrorCode::NoSuchDevice => "no-such-device",
                        ErrorCode::Overflow => "overflow",
                        ErrorCode::NotPermitted => "not-permitted",
                        ErrorCode::Pipe => "pipe",
                        ErrorCode::ReadOnly => "read-only",
                        ErrorCode::InvalidSeek => "invalid-seek",
                        ErrorCode::TextFileBusy => "text-file-busy",
                        ErrorCode::CrossDevice => "cross-device",
                    }
                }
                pub fn message(&self) -> &'static str {
                    match self {
                        ErrorCode::Access => {
                            "Permission denied, similar to `EACCES` in POSIX."
                        }
                        ErrorCode::Already => {
                            "Connection already in progress, similar to `EALREADY` in POSIX."
                        }
                        ErrorCode::BadDescriptor => {
                            "Bad descriptor, similar to `EBADF` in POSIX."
                        }
                        ErrorCode::Busy => {
                            "Device or resource busy, similar to `EBUSY` in POSIX."
                        }
                        ErrorCode::Deadlock => {
                            "Resource deadlock would occur, similar to `EDEADLK` in POSIX."
                        }
                        ErrorCode::Quota => {
                            "Storage quota exceeded, similar to `EDQUOT` in POSIX."
                        }
                        ErrorCode::Exist => "File exists, similar to `EEXIST` in POSIX.",
                        ErrorCode::FileTooLarge => {
                            "File too large, similar to `EFBIG` in POSIX."
                        }
                        ErrorCode::IllegalByteSequence => {
                            "Illegal byte sequence, similar to `EILSEQ` in POSIX."
                        }
                        ErrorCode::InProgress => {
                            "Operation in progress, similar to `EINPROGRESS` in POSIX."
                        }
                        ErrorCode::Interrupted => {
                            "Interrupted function, similar to `EINTR` in POSIX."
                        }
                        ErrorCode::Invalid => {
                            "Invalid argument, similar to `EINVAL` in POSIX."
                        }
                        ErrorCode::Io => "I/O error, similar to `EIO` in POSIX.",
                        ErrorCode::IsDirectory => {
                            "Is a directory, similar to `EISDIR` in POSIX."
                        }
                        ErrorCode::Loop => {
                            "Too many levels of symbolic links, similar to `ELOOP` in POSIX."
                        }
                        ErrorCode::TooManyLinks => {
                            "Too many links, similar to `EMLINK` in POSIX."
                        }
                        ErrorCode::MessageSize => {
                            "Message too large, similar to `EMSGSIZE` in POSIX."
                        }
                        ErrorCode::NameTooLong => {
                            "Filename too long, similar to `ENAMETOOLONG` in POSIX."
                        }
                        ErrorCode::NoDevice => {
                            "No such device, similar to `ENODEV` in POSIX."
                        }
                        ErrorCode::NoEntry => {
                            "No such file or directory, similar to `ENOENT` in POSIX."
                        }
                        ErrorCode::NoLock => {
                            "No locks available, similar to `ENOLCK` in POSIX."
                        }
                        ErrorCode::InsufficientMemory => {
                            "Not enough space, similar to `ENOMEM` in POSIX."
                        }
                        ErrorCode::InsufficientSpace => {
                            "No space left on device, similar to `ENOSPC` in POSIX."
                        }
                        ErrorCode::NotDirectory => {
                            "Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX."
                        }
                        ErrorCode::NotEmpty => {
                            "Directory not empty, similar to `ENOTEMPTY` in POSIX."
                        }
                        ErrorCode::NotRecoverable => {
                            "State not recoverable, similar to `ENOTRECOVERABLE` in POSIX."
                        }
                        ErrorCode::Unsupported => {
                            "Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX."
                        }
                        ErrorCode::NoTty => {
                            "Inappropriate I/O control operation, similar to `ENOTTY` in POSIX."
                        }
                        ErrorCode::NoSuchDevice => {
                            "No such device or address, similar to `ENXIO` in POSIX."
                        }
                        ErrorCode::Overflow => {
                            "Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX."
                        }
                        ErrorCode::NotPermitted => {
                            "Operation not permitted, similar to `EPERM` in POSIX."
                        }
                        ErrorCode::Pipe => "Broken pipe, similar to `EPIPE` in POSIX.",
                        ErrorCode::ReadOnly => {
                            "Read-only file system, similar to `EROFS` in POSIX."
                        }
                        ErrorCode::InvalidSeek => {
                            "Invalid seek, similar to `ESPIPE` in POSIX."
                        }
                        ErrorCode::TextFileBusy => {
                            "Text file busy, similar to `ETXTBSY` in POSIX."
                        }
                        ErrorCode::CrossDevice => {
                            "Cross-device link, similar to `EXDEV` in POSIX."
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for ErrorCode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ErrorCode")
                        .field("code", &(*self as i32))
                        .field("name", &self.name())
                        .field("message", &self.message())
                        .finish()
                }
            }
            impl ::core::fmt::Display for ErrorCode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{} (error {})", self.name(), * self as i32)
                }
            }
            impl std::error::Error for ErrorCode {}
            impl ErrorCode {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> ErrorCode {
                    if !cfg!(debug_assertions) {
                        return unsafe { ::core::mem::transmute(val) };
                    }
                    match val {
                        0 => ErrorCode::Access,
                        1 => ErrorCode::Already,
                        2 => ErrorCode::BadDescriptor,
                        3 => ErrorCode::Busy,
                        4 => ErrorCode::Deadlock,
                        5 => ErrorCode::Quota,
                        6 => ErrorCode::Exist,
                        7 => ErrorCode::FileTooLarge,
                        8 => ErrorCode::IllegalByteSequence,
                        9 => ErrorCode::InProgress,
                        10 => ErrorCode::Interrupted,
                        11 => ErrorCode::Invalid,
                        12 => ErrorCode::Io,
                        13 => ErrorCode::IsDirectory,
                        14 => ErrorCode::Loop,
                        15 => ErrorCode::TooManyLinks,
                        16 => ErrorCode::MessageSize,
                        17 => ErrorCode::NameTooLong,
                        18 => ErrorCode::NoDevice,
                        19 => ErrorCode::NoEntry,
                        20 => ErrorCode::NoLock,
                        21 => ErrorCode::InsufficientMemory,
                        22 => ErrorCode::InsufficientSpace,
                        23 => ErrorCode::NotDirectory,
                        24 => ErrorCode::NotEmpty,
                        25 => ErrorCode::NotRecoverable,
                        26 => ErrorCode::Unsupported,
                        27 => ErrorCode::NoTty,
                        28 => ErrorCode::NoSuchDevice,
                        29 => ErrorCode::Overflow,
                        30 => ErrorCode::NotPermitted,
                        31 => ErrorCode::Pipe,
                        32 => ErrorCode::ReadOnly,
                        33 => ErrorCode::InvalidSeek,
                        34 => ErrorCode::TextFileBusy,
                        35 => ErrorCode::CrossDevice,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// File or memory access pattern advisory information.
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum Advice {
                /// The application has no advice to give on its behavior with respect
                /// to the specified data.
                Normal,
                /// The application expects to access the specified data sequentially
                /// from lower offsets to higher offsets.
                Sequential,
                /// The application expects to access the specified data in a random
                /// order.
                Random,
                /// The application expects to access the specified data in the near
                /// future.
                WillNeed,
                /// The application expects that it will not access the specified data
                /// in the near future.
                DontNeed,
                /// The application expects to access the specified data once and then
                /// not reuse it thereafter.
                NoReuse,
            }
            impl ::core::fmt::Debug for Advice {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Advice::Normal => f.debug_tuple("Advice::Normal").finish(),
                        Advice::Sequential => {
                            f.debug_tuple("Advice::Sequential").finish()
                        }
                        Advice::Random => f.debug_tuple("Advice::Random").finish(),
                        Advice::WillNeed => f.debug_tuple("Advice::WillNeed").finish(),
                        Advice::DontNeed => f.debug_tuple("Advice::DontNeed").finish(),
                        Advice::NoReuse => f.debug_tuple("Advice::NoReuse").finish(),
                    }
                }
            }
            impl Advice {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> Advice {
                    if !cfg!(debug_assertions) {
                        return unsafe { ::core::mem::transmute(val) };
                    }
                    match val {
                        0 => Advice::Normal,
                        1 => Advice::Sequential,
                        2 => Advice::Random,
                        3 => Advice::WillNeed,
                        4 => Advice::DontNeed,
                        5 => Advice::NoReuse,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// A 128-bit hash value, split into parts because wasm doesn't have a
            /// 128-bit integer type.
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct MetadataHashValue {
                /// 64 bits of a 128-bit hash value.
                pub lower: u64,
                /// Another 64 bits of a 128-bit hash value.
                pub upper: u64,
            }
            impl ::core::fmt::Debug for MetadataHashValue {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("MetadataHashValue")
                        .field("lower", &self.lower)
                        .field("upper", &self.upper)
                        .finish()
                }
            }
            /// A descriptor is a reference to a filesystem object, which may be a file,
            /// directory, named pipe, special file, or other object on which filesystem
            /// calls may be made.
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Descriptor {
                handle: _rt::Resource<Descriptor>,
            }
            impl Descriptor {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Descriptor {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "[resource-drop]descriptor"]
                        fn drop(_: i32);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn drop(_: i32) {
                        unreachable!()
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Return a stream for reading from a file.
                ///
                /// Multiple read, write, and append streams may be active on the same open
                /// file and they do not interfere with each other.
                ///
                /// This function returns a `stream` which provides the data received from the
                /// file, and a `future` providing additional error information in case an
                /// error is encountered.
                ///
                /// If no error is encountered, `stream.read` on the `stream` will return
                /// `read-status::closed` with no `error-context` and the future resolves to
                /// the value `ok`. If an error is encountered, `stream.read` on the
                /// `stream` returns `read-status::closed` with an `error-context` and the future
                /// resolves to `err` with an `error-code`.
                ///
                /// Note: This is similar to `pread` in POSIX.
                #[allow(async_fn_in_trait)]
                pub fn read_via_stream(
                    &self,
                    offset: Filesize,
                ) -> (
                    wit_bindgen::rt::async_support::StreamReader<u8>,
                    wit_bindgen::rt::async_support::FutureReader<Result<(), ErrorCode>>,
                ) {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.read-via-stream"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(offset), ptr0);
                        let l2 = *ptr0.add(0).cast::<i32>();
                        let l3 = *ptr0.add(4).cast::<i32>();
                        let result4 = (
                            wit_bindgen::rt::async_support::StreamReader::new(
                                l2 as u32,
                                &super::super::super::wit_stream::vtable0::VTABLE,
                            ),
                            wit_bindgen::rt::async_support::FutureReader::new(
                                l3 as u32,
                                &super::super::super::wit_future::vtable0::VTABLE,
                            ),
                        );
                        result4
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Return a stream for writing to a file, if available.
                ///
                /// May fail with an error-code describing why the file cannot be written.
                ///
                /// It is valid to write past the end of a file; the file is extended to the
                /// extent of the write, with bytes between the previous end and the start of
                /// the write set to zero.
                ///
                /// This function returns once either full contents of the stream are
                /// written or an error is encountered.
                ///
                /// Note: This is similar to `pwrite` in POSIX.
                #[allow(async_fn_in_trait)]
                pub async fn write_via_stream(
                    &self,
                    data: wit_bindgen::rt::async_support::StreamReader<u8>,
                    offset: Filesize,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (
                                &'a Descriptor,
                                wit_bindgen::rt::async_support::StreamReader<u8>,
                                Filesize,
                            );
                            type Results = Result<(), ErrorCode>;
                            type ParamsLower = (i32, i32, i64);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(2, 1)
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.write-via-stream"]
                                    fn call(_: i32, _: i32, _: i64, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(
                                    _: i32,
                                    _: i32,
                                    _: i64,
                                    _: *mut u8,
                                ) -> i32 {
                                    unreachable!()
                                }
                                unsafe {
                                    call(_params.0, _params.1, _params.2, _results) as u32
                                }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {}
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {
                                    let _ = wit_bindgen::rt::async_support::StreamReader::new(
                                        _params.1 as u32,
                                        &super::super::super::wit_stream::vtable0::VTABLE,
                                    );
                                }
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1, _lower2): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe {
                                    (
                                        (_lower0).handle() as i32,
                                        (_lower1).take_handle() as i32,
                                        _rt::as_i64(_lower2),
                                    )
                                }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = ();
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(1).cast::<u8>());
                                                ErrorCode::_lift(l1 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self, data, offset)).await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Return a stream for appending to a file, if available.
                ///
                /// May fail with an error-code describing why the file cannot be appended.
                ///
                /// This function returns once either full contents of the stream are
                /// written or an error is encountered.
                ///
                /// Note: This is similar to `write` with `O_APPEND` in POSIX.
                #[allow(async_fn_in_trait)]
                pub async fn append_via_stream(
                    &self,
                    data: wit_bindgen::rt::async_support::StreamReader<u8>,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (
                                &'a Descriptor,
                                wit_bindgen::rt::async_support::StreamReader<u8>,
                            );
                            type Results = Result<(), ErrorCode>;
                            type ParamsLower = (i32, i32);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(2, 1)
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.append-via-stream"]
                                    fn call(_: i32, _: i32, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(
                                    _: i32,
                                    _: i32,
                                    _: *mut u8,
                                ) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _params.1, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {}
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {
                                    let _ = wit_bindgen::rt::async_support::StreamReader::new(
                                        _params.1 as u32,
                                        &super::super::super::wit_stream::vtable0::VTABLE,
                                    );
                                }
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe {
                                    ((_lower0).handle() as i32, (_lower1).take_handle() as i32)
                                }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = ();
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(1).cast::<u8>());
                                                ErrorCode::_lift(l1 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self, data)).await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Provide file advisory information on a descriptor.
                ///
                /// This is similar to `posix_fadvise` in POSIX.
                #[allow(async_fn_in_trait)]
                pub async fn advise(
                    &self,
                    offset: Filesize,
                    length: Filesize,
                    advice: Advice,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a Descriptor, Filesize, Filesize, Advice);
                            type Results = Result<(), ErrorCode>;
                            type ParamsLower = (i32, i64, i64, i32);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(2, 1)
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.advise"]
                                    fn call(_: i32, _: i64, _: i64, _: i32, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(
                                    _: i32,
                                    _: i64,
                                    _: i64,
                                    _: i32,
                                    _: *mut u8,
                                ) -> i32 {
                                    unreachable!()
                                }
                                unsafe {
                                    call(_params.0, _params.1, _params.2, _params.3, _results)
                                        as u32
                                }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {}
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {}
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1, _lower2, _lower3): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe {
                                    (
                                        (_lower0).handle() as i32,
                                        _rt::as_i64(_lower1),
                                        _rt::as_i64(_lower2),
                                        _lower3.clone() as i32,
                                    )
                                }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = ();
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(1).cast::<u8>());
                                                ErrorCode::_lift(l1 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self, offset, length, advice)).await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Synchronize the data of a file to disk.
                ///
                /// This function succeeds with no effect if the file descriptor is not
                /// opened for writing.
                ///
                /// Note: This is similar to `fdatasync` in POSIX.
                #[allow(async_fn_in_trait)]
                pub async fn sync_data(&self) -> Result<(), ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a Descriptor,);
                            type Results = Result<(), ErrorCode>;
                            type ParamsLower = (i32,);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(2, 1)
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.sync-data"]
                                    fn call(_: i32, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(_: i32, _: *mut u8) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {}
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {}
                            }
                            unsafe fn params_lower(
                                (_lower0,): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe { ((_lower0).handle() as i32,) }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = ();
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(1).cast::<u8>());
                                                ErrorCode::_lift(l1 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self,)).await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Get flags associated with a descriptor.
                ///
                /// Note: This returns similar flags to `fcntl(fd, F_GETFL)` in POSIX.
                ///
                /// Note: This returns the value that was the `fs_flags` value returned
                /// from `fdstat_get` in earlier versions of WASI.
                #[allow(async_fn_in_trait)]
                pub async fn get_flags(&self) -> Result<DescriptorFlags, ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a Descriptor,);
                            type Results = Result<DescriptorFlags, ErrorCode>;
                            type ParamsLower = (i32,);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(2, 1)
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.get-flags"]
                                    fn call(_: i32, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(_: i32, _: *mut u8) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {}
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {}
                            }
                            unsafe fn params_lower(
                                (_lower0,): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe { ((_lower0).handle() as i32,) }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(1).cast::<u8>());
                                                DescriptorFlags::empty()
                                                    | DescriptorFlags::from_bits_retain(((l1 as u8) << 0) as _)
                                            };
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l2 = i32::from(*_ptr.add(1).cast::<u8>());
                                                ErrorCode::_lift(l2 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self,)).await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Get the dynamic type of a descriptor.
                ///
                /// Note: This returns the same value as the `type` field of the `fd-stat`
                /// returned by `stat`, `stat-at` and similar.
                ///
                /// Note: This returns similar flags to the `st_mode & S_IFMT` value provided
                /// by `fstat` in POSIX.
                ///
                /// Note: This returns the value that was the `fs_filetype` value returned
                /// from `fdstat_get` in earlier versions of WASI.
                #[allow(async_fn_in_trait)]
                pub async fn get_type(&self) -> Result<DescriptorType, ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a Descriptor,);
                            type Results = Result<DescriptorType, ErrorCode>;
                            type ParamsLower = (i32,);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(2, 1)
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.get-type"]
                                    fn call(_: i32, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(_: i32, _: *mut u8) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {}
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {}
                            }
                            unsafe fn params_lower(
                                (_lower0,): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe { ((_lower0).handle() as i32,) }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(1).cast::<u8>());
                                                DescriptorType::_lift(l1 as u8)
                                            };
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l2 = i32::from(*_ptr.add(1).cast::<u8>());
                                                ErrorCode::_lift(l2 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self,)).await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Adjust the size of an open file. If this increases the file's size, the
                /// extra bytes are filled with zeros.
                ///
                /// Note: This was called `fd_filestat_set_size` in earlier versions of WASI.
                #[allow(async_fn_in_trait)]
                pub async fn set_size(&self, size: Filesize) -> Result<(), ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a Descriptor, Filesize);
                            type Results = Result<(), ErrorCode>;
                            type ParamsLower = (i32, i64);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(2, 1)
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.set-size"]
                                    fn call(_: i32, _: i64, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(
                                    _: i32,
                                    _: i64,
                                    _: *mut u8,
                                ) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _params.1, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {}
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {}
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe { ((_lower0).handle() as i32, _rt::as_i64(_lower1)) }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = ();
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(1).cast::<u8>());
                                                ErrorCode::_lift(l1 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self, size)).await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Adjust the timestamps of an open file or directory.
                ///
                /// Note: This is similar to `futimens` in POSIX.
                ///
                /// Note: This was called `fd_filestat_set_times` in earlier versions of WASI.
                #[allow(async_fn_in_trait)]
                pub async fn set_times(
                    &self,
                    data_access_timestamp: NewTimestamp,
                    data_modification_timestamp: NewTimestamp,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a Descriptor, NewTimestamp, NewTimestamp);
                            type Results = Result<(), ErrorCode>;
                            type ParamsLower = (*mut u8,);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(64, 8)
                            };
                            const RESULTS_OFFSET: usize = 56;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.set-times"]
                                    fn call(_: *mut u8, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(_: *mut u8, _: *mut u8) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {}
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {}
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1, _lower2): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                let _param_ptr = unsafe { _ptr.add(0) };
                                unsafe {
                                    *_param_ptr.add(0).cast::<i32>() = (_lower0).handle()
                                        as i32;
                                }
                                let _param_ptr = unsafe { _ptr.add(8) };
                                unsafe {
                                    match _lower1 {
                                        NewTimestamp::NoChange => {
                                            *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
                                        }
                                        NewTimestamp::Now => {
                                            *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
                                        }
                                        NewTimestamp::Timestamp(e) => {
                                            *_param_ptr.add(0).cast::<u8>() = (2i32) as u8;
                                            let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                seconds: seconds0,
                                                nanoseconds: nanoseconds0,
                                            } = e;
                                            *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(seconds0);
                                            *_param_ptr.add(16).cast::<i32>() = _rt::as_i32(
                                                nanoseconds0,
                                            );
                                        }
                                    }
                                }
                                let _param_ptr = unsafe { _ptr.add(32) };
                                unsafe {
                                    match _lower2 {
                                        NewTimestamp::NoChange => {
                                            *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
                                        }
                                        NewTimestamp::Now => {
                                            *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
                                        }
                                        NewTimestamp::Timestamp(e) => {
                                            *_param_ptr.add(0).cast::<u8>() = (2i32) as u8;
                                            let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                seconds: seconds0,
                                                nanoseconds: nanoseconds0,
                                            } = e;
                                            *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(seconds0);
                                            *_param_ptr.add(16).cast::<i32>() = _rt::as_i32(
                                                nanoseconds0,
                                            );
                                        }
                                    }
                                }
                                (_ptr,)
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = ();
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(1).cast::<u8>());
                                                ErrorCode::_lift(l1 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((
                                self,
                                data_access_timestamp,
                                data_modification_timestamp,
                            ))
                            .await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Read directory entries from a directory.
                ///
                /// On filesystems where directories contain entries referring to themselves
                /// and their parents, often named `.` and `..` respectively, these entries
                /// are omitted.
                ///
                /// This always returns a new stream which starts at the beginning of the
                /// directory. Multiple streams may be active on the same directory, and they
                /// do not interfere with each other.
                ///
                /// This function returns a future, which will resolve to an error code if
                /// reading full contents of the directory fails.
                #[allow(async_fn_in_trait)]
                pub async fn read_directory(
                    &self,
                ) -> (
                    wit_bindgen::rt::async_support::StreamReader<DirectoryEntry>,
                    wit_bindgen::rt::async_support::FutureReader<Result<(), ErrorCode>>,
                ) {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a Descriptor,);
                            type Results = (
                                wit_bindgen::rt::async_support::StreamReader<
                                    DirectoryEntry,
                                >,
                                wit_bindgen::rt::async_support::FutureReader<
                                    Result<(), ErrorCode>,
                                >,
                            );
                            type ParamsLower = (i32,);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(8, 4)
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.read-directory"]
                                    fn call(_: i32, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(_: i32, _: *mut u8) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {}
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {}
                            }
                            unsafe fn params_lower(
                                (_lower0,): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe { ((_lower0).handle() as i32,) }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = *_ptr.add(0).cast::<i32>();
                                    let l1 = *_ptr.add(4).cast::<i32>();
                                    (
                                        wit_bindgen::rt::async_support::StreamReader::new(
                                            l0 as u32,
                                            &super::super::super::wit_stream::vtable1::VTABLE,
                                        ),
                                        wit_bindgen::rt::async_support::FutureReader::new(
                                            l1 as u32,
                                            &super::super::super::wit_future::vtable0::VTABLE,
                                        ),
                                    )
                                }
                            }
                        }
                        _MySubtask::call((self,)).await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Synchronize the data and metadata of a file to disk.
                ///
                /// This function succeeds with no effect if the file descriptor is not
                /// opened for writing.
                ///
                /// Note: This is similar to `fsync` in POSIX.
                #[allow(async_fn_in_trait)]
                pub async fn sync(&self) -> Result<(), ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a Descriptor,);
                            type Results = Result<(), ErrorCode>;
                            type ParamsLower = (i32,);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(2, 1)
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.sync"]
                                    fn call(_: i32, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(_: i32, _: *mut u8) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {}
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {}
                            }
                            unsafe fn params_lower(
                                (_lower0,): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe { ((_lower0).handle() as i32,) }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = ();
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(1).cast::<u8>());
                                                ErrorCode::_lift(l1 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self,)).await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Create a directory.
                ///
                /// Note: This is similar to `mkdirat` in POSIX.
                #[allow(async_fn_in_trait)]
                pub async fn create_directory_at(
                    &self,
                    path: _rt::String,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a Descriptor, _rt::String);
                            type Results = Result<(), ErrorCode>;
                            type ParamsLower = (i32, *mut u8, usize);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(2, 1)
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.create-directory-at"]
                                    fn call(_: i32, _: *mut u8, _: usize, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(
                                    _: i32,
                                    _: *mut u8,
                                    _: usize,
                                    _: *mut u8,
                                ) -> i32 {
                                    unreachable!()
                                }
                                unsafe {
                                    call(_params.0, _params.1, _params.2, _results) as u32
                                }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {
                                    _rt::cabi_dealloc(_params.1, _params.2, 1);
                                }
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {
                                    _rt::cabi_dealloc(_params.1, _params.2, 1);
                                }
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe {
                                    let vec0 = (_lower1.into_bytes()).into_boxed_slice();
                                    let ptr0 = vec0.as_ptr().cast::<u8>();
                                    let len0 = vec0.len();
                                    ::core::mem::forget(vec0);
                                    ((_lower0).handle() as i32, ptr0.cast_mut(), len0)
                                }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = ();
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(1).cast::<u8>());
                                                ErrorCode::_lift(l1 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self, path)).await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Return the attributes of an open file or directory.
                ///
                /// Note: This is similar to `fstat` in POSIX, except that it does not return
                /// device and inode information. For testing whether two descriptors refer to
                /// the same underlying filesystem object, use `is-same-object`. To obtain
                /// additional data that can be used do determine whether a file has been
                /// modified, use `metadata-hash`.
                ///
                /// Note: This was called `fd_filestat_get` in earlier versions of WASI.
                #[allow(async_fn_in_trait)]
                pub async fn stat(&self) -> Result<DescriptorStat, ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a Descriptor,);
                            type Results = Result<DescriptorStat, ErrorCode>;
                            type ParamsLower = (i32,);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(104, 8)
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.stat"]
                                    fn call(_: i32, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(_: i32, _: *mut u8) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {}
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {}
                            }
                            unsafe fn params_lower(
                                (_lower0,): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe { ((_lower0).handle() as i32,) }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(8).cast::<u8>());
                                                let l2 = *_ptr.add(16).cast::<i64>();
                                                let l3 = *_ptr.add(24).cast::<i64>();
                                                let l4 = i32::from(*_ptr.add(32).cast::<u8>());
                                                let l7 = i32::from(*_ptr.add(56).cast::<u8>());
                                                let l10 = i32::from(*_ptr.add(80).cast::<u8>());
                                                DescriptorStat {
                                                    type_: DescriptorType::_lift(l1 as u8),
                                                    link_count: l2 as u64,
                                                    size: l3 as u64,
                                                    data_access_timestamp: match l4 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l5 = *_ptr.add(40).cast::<i64>();
                                                                let l6 = *_ptr.add(48).cast::<i32>();
                                                                super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                    seconds: l5 as u64,
                                                                    nanoseconds: l6 as u32,
                                                                }
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    data_modification_timestamp: match l7 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l8 = *_ptr.add(64).cast::<i64>();
                                                                let l9 = *_ptr.add(72).cast::<i32>();
                                                                super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                    seconds: l8 as u64,
                                                                    nanoseconds: l9 as u32,
                                                                }
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    status_change_timestamp: match l10 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l11 = *_ptr.add(88).cast::<i64>();
                                                                let l12 = *_ptr.add(96).cast::<i32>();
                                                                super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                    seconds: l11 as u64,
                                                                    nanoseconds: l12 as u32,
                                                                }
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                }
                                            };
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l13 = i32::from(*_ptr.add(8).cast::<u8>());
                                                ErrorCode::_lift(l13 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self,)).await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Return the attributes of a file or directory.
                ///
                /// Note: This is similar to `fstatat` in POSIX, except that it does not
                /// return device and inode information. See the `stat` description for a
                /// discussion of alternatives.
                ///
                /// Note: This was called `path_filestat_get` in earlier versions of WASI.
                #[allow(async_fn_in_trait)]
                pub async fn stat_at(
                    &self,
                    path_flags: PathFlags,
                    path: _rt::String,
                ) -> Result<DescriptorStat, ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a Descriptor, PathFlags, _rt::String);
                            type Results = Result<DescriptorStat, ErrorCode>;
                            type ParamsLower = (i32, i32, *mut u8, usize);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(104, 8)
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.stat-at"]
                                    fn call(
                                        _: i32,
                                        _: i32,
                                        _: *mut u8,
                                        _: usize,
                                        _: *mut u8,
                                    ) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(
                                    _: i32,
                                    _: i32,
                                    _: *mut u8,
                                    _: usize,
                                    _: *mut u8,
                                ) -> i32 {
                                    unreachable!()
                                }
                                unsafe {
                                    call(_params.0, _params.1, _params.2, _params.3, _results)
                                        as u32
                                }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {
                                    _rt::cabi_dealloc(_params.2, _params.3, 1);
                                }
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {
                                    _rt::cabi_dealloc(_params.2, _params.3, 1);
                                }
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1, _lower2): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe {
                                    let flags0 = _lower1;
                                    let vec1 = (_lower2.into_bytes()).into_boxed_slice();
                                    let ptr1 = vec1.as_ptr().cast::<u8>();
                                    let len1 = vec1.len();
                                    ::core::mem::forget(vec1);
                                    (
                                        (_lower0).handle() as i32,
                                        (flags0.bits() >> 0) as i32,
                                        ptr1.cast_mut(),
                                        len1,
                                    )
                                }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(8).cast::<u8>());
                                                let l2 = *_ptr.add(16).cast::<i64>();
                                                let l3 = *_ptr.add(24).cast::<i64>();
                                                let l4 = i32::from(*_ptr.add(32).cast::<u8>());
                                                let l7 = i32::from(*_ptr.add(56).cast::<u8>());
                                                let l10 = i32::from(*_ptr.add(80).cast::<u8>());
                                                DescriptorStat {
                                                    type_: DescriptorType::_lift(l1 as u8),
                                                    link_count: l2 as u64,
                                                    size: l3 as u64,
                                                    data_access_timestamp: match l4 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l5 = *_ptr.add(40).cast::<i64>();
                                                                let l6 = *_ptr.add(48).cast::<i32>();
                                                                super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                    seconds: l5 as u64,
                                                                    nanoseconds: l6 as u32,
                                                                }
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    data_modification_timestamp: match l7 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l8 = *_ptr.add(64).cast::<i64>();
                                                                let l9 = *_ptr.add(72).cast::<i32>();
                                                                super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                    seconds: l8 as u64,
                                                                    nanoseconds: l9 as u32,
                                                                }
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    status_change_timestamp: match l10 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l11 = *_ptr.add(88).cast::<i64>();
                                                                let l12 = *_ptr.add(96).cast::<i32>();
                                                                super::super::super::wasi::clocks::wall_clock::Datetime {
                                                                    seconds: l11 as u64,
                                                                    nanoseconds: l12 as u32,
                                                                }
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                }
                                            };
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l13 = i32::from(*_ptr.add(8).cast::<u8>());
                                                ErrorCode::_lift(l13 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self, path_flags, path)).await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Adjust the timestamps of a file or directory.
                ///
                /// Note: This is similar to `utimensat` in POSIX.
                ///
                /// Note: This was called `path_filestat_set_times` in earlier versions of
                /// WASI.
                #[allow(async_fn_in_trait)]
                pub async fn set_times_at(
                    &self,
                    path_flags: PathFlags,
                    path: _rt::String,
                    data_access_timestamp: NewTimestamp,
                    data_modification_timestamp: NewTimestamp,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (
                                &'a Descriptor,
                                PathFlags,
                                _rt::String,
                                NewTimestamp,
                                NewTimestamp,
                            );
                            type Results = Result<(), ErrorCode>;
                            type ParamsLower = (*mut u8,);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(
                                    (64 + 2 * ::core::mem::size_of::<*const u8>()),
                                    8,
                                )
                            };
                            const RESULTS_OFFSET: usize = (56
                                + 2 * ::core::mem::size_of::<*const u8>());
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.set-times-at"]
                                    fn call(_: *mut u8, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(_: *mut u8, _: *mut u8) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {
                                    let l0 = *_params.0.add(8).cast::<*mut u8>();
                                    let l1 = *_params
                                        .0
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l0, l1, 1);
                                }
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {
                                    let l0 = *_params.0.add(8).cast::<*mut u8>();
                                    let l1 = *_params
                                        .0
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l0, l1, 1);
                                }
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1, _lower2, _lower3, _lower4): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                let _param_ptr = unsafe { _ptr.add(0) };
                                unsafe {
                                    *_param_ptr.add(0).cast::<i32>() = (_lower0).handle()
                                        as i32;
                                }
                                let _param_ptr = unsafe { _ptr.add(4) };
                                unsafe {
                                    let flags0 = _lower1;
                                    *_param_ptr.add(0).cast::<u8>() = ((flags0.bits() >> 0)
                                        as i32) as u8;
                                }
                                let _param_ptr = unsafe { _ptr.add(8) };
                                unsafe {
                                    let vec0 = (_lower2.into_bytes()).into_boxed_slice();
                                    let ptr0 = vec0.as_ptr().cast::<u8>();
                                    let len0 = vec0.len();
                                    ::core::mem::forget(vec0);
                                    *_param_ptr
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len0;
                                    *_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
                                }
                                let _param_ptr = unsafe {
                                    _ptr.add((8 + 2 * ::core::mem::size_of::<*const u8>()))
                                };
                                unsafe {
                                    match _lower3 {
                                        NewTimestamp::NoChange => {
                                            *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
                                        }
                                        NewTimestamp::Now => {
                                            *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
                                        }
                                        NewTimestamp::Timestamp(e) => {
                                            *_param_ptr.add(0).cast::<u8>() = (2i32) as u8;
                                            let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                seconds: seconds0,
                                                nanoseconds: nanoseconds0,
                                            } = e;
                                            *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(seconds0);
                                            *_param_ptr.add(16).cast::<i32>() = _rt::as_i32(
                                                nanoseconds0,
                                            );
                                        }
                                    }
                                }
                                let _param_ptr = unsafe {
                                    _ptr.add((32 + 2 * ::core::mem::size_of::<*const u8>()))
                                };
                                unsafe {
                                    match _lower4 {
                                        NewTimestamp::NoChange => {
                                            *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
                                        }
                                        NewTimestamp::Now => {
                                            *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
                                        }
                                        NewTimestamp::Timestamp(e) => {
                                            *_param_ptr.add(0).cast::<u8>() = (2i32) as u8;
                                            let super::super::super::wasi::clocks::wall_clock::Datetime {
                                                seconds: seconds0,
                                                nanoseconds: nanoseconds0,
                                            } = e;
                                            *_param_ptr.add(8).cast::<i64>() = _rt::as_i64(seconds0);
                                            *_param_ptr.add(16).cast::<i32>() = _rt::as_i32(
                                                nanoseconds0,
                                            );
                                        }
                                    }
                                }
                                (_ptr,)
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = ();
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(1).cast::<u8>());
                                                ErrorCode::_lift(l1 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((
                                self,
                                path_flags,
                                path,
                                data_access_timestamp,
                                data_modification_timestamp,
                            ))
                            .await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Create a hard link.
                ///
                /// Fails with `error-code::no-entry` if the old path does not exist,
                /// with `error-code::exist` if the new path already exists, and
                /// `error-code::not-permitted` if the old path is not a file.
                ///
                /// Note: This is similar to `linkat` in POSIX.
                #[allow(async_fn_in_trait)]
                pub async fn link_at(
                    &self,
                    old_path_flags: PathFlags,
                    old_path: _rt::String,
                    new_descriptor: &Descriptor,
                    new_path: _rt::String,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (
                                &'a Descriptor,
                                PathFlags,
                                _rt::String,
                                &'a Descriptor,
                                _rt::String,
                            );
                            type Results = Result<(), ErrorCode>;
                            type ParamsLower = (*mut u8,);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(
                                    (8 + 6 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                )
                            };
                            const RESULTS_OFFSET: usize = (8
                                + 5 * ::core::mem::size_of::<*const u8>());
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.link-at"]
                                    fn call(_: *mut u8, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(_: *mut u8, _: *mut u8) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {
                                    let l0 = *_params.0.add(8).cast::<*mut u8>();
                                    let l1 = *_params
                                        .0
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l0, l1, 1);
                                    let l2 = *_params
                                        .0
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l3 = *_params
                                        .0
                                        .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {
                                    let l0 = *_params.0.add(8).cast::<*mut u8>();
                                    let l1 = *_params
                                        .0
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l0, l1, 1);
                                    let l2 = *_params
                                        .0
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l3 = *_params
                                        .0
                                        .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1, _lower2, _lower3, _lower4): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                let _param_ptr = unsafe { _ptr.add(0) };
                                unsafe {
                                    *_param_ptr.add(0).cast::<i32>() = (_lower0).handle()
                                        as i32;
                                }
                                let _param_ptr = unsafe { _ptr.add(4) };
                                unsafe {
                                    let flags0 = _lower1;
                                    *_param_ptr.add(0).cast::<u8>() = ((flags0.bits() >> 0)
                                        as i32) as u8;
                                }
                                let _param_ptr = unsafe { _ptr.add(8) };
                                unsafe {
                                    let vec0 = (_lower2.into_bytes()).into_boxed_slice();
                                    let ptr0 = vec0.as_ptr().cast::<u8>();
                                    let len0 = vec0.len();
                                    ::core::mem::forget(vec0);
                                    *_param_ptr
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len0;
                                    *_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
                                }
                                let _param_ptr = unsafe {
                                    _ptr.add((8 + 2 * ::core::mem::size_of::<*const u8>()))
                                };
                                unsafe {
                                    *_param_ptr.add(0).cast::<i32>() = (_lower3).handle()
                                        as i32;
                                }
                                let _param_ptr = unsafe {
                                    _ptr.add((8 + 3 * ::core::mem::size_of::<*const u8>()))
                                };
                                unsafe {
                                    let vec0 = (_lower4.into_bytes()).into_boxed_slice();
                                    let ptr0 = vec0.as_ptr().cast::<u8>();
                                    let len0 = vec0.len();
                                    ::core::mem::forget(vec0);
                                    *_param_ptr
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len0;
                                    *_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
                                }
                                (_ptr,)
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = ();
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(1).cast::<u8>());
                                                ErrorCode::_lift(l1 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((
                                self,
                                old_path_flags,
                                old_path,
                                new_descriptor,
                                new_path,
                            ))
                            .await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Open a file or directory.
                ///
                /// If `flags` contains `descriptor-flags::mutate-directory`, and the base
                /// descriptor doesn't have `descriptor-flags::mutate-directory` set,
                /// `open-at` fails with `error-code::read-only`.
                ///
                /// If `flags` contains `write` or `mutate-directory`, or `open-flags`
                /// contains `truncate` or `create`, and the base descriptor doesn't have
                /// `descriptor-flags::mutate-directory` set, `open-at` fails with
                /// `error-code::read-only`.
                ///
                /// Note: This is similar to `openat` in POSIX.
                #[allow(async_fn_in_trait)]
                pub async fn open_at(
                    &self,
                    path_flags: PathFlags,
                    path: _rt::String,
                    open_flags: OpenFlags,
                    flags: DescriptorFlags,
                ) -> Result<Descriptor, ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (
                                &'a Descriptor,
                                PathFlags,
                                _rt::String,
                                OpenFlags,
                                DescriptorFlags,
                            );
                            type Results = Result<Descriptor, ErrorCode>;
                            type ParamsLower = (*mut u8,);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(
                                    (16 + 3 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                )
                            };
                            const RESULTS_OFFSET: usize = (12
                                + 2 * ::core::mem::size_of::<*const u8>());
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.open-at"]
                                    fn call(_: *mut u8, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(_: *mut u8, _: *mut u8) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {
                                    let l0 = *_params.0.add(8).cast::<*mut u8>();
                                    let l1 = *_params
                                        .0
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l0, l1, 1);
                                }
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {
                                    let l0 = *_params.0.add(8).cast::<*mut u8>();
                                    let l1 = *_params
                                        .0
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l0, l1, 1);
                                }
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1, _lower2, _lower3, _lower4): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                let _param_ptr = unsafe { _ptr.add(0) };
                                unsafe {
                                    *_param_ptr.add(0).cast::<i32>() = (_lower0).handle()
                                        as i32;
                                }
                                let _param_ptr = unsafe { _ptr.add(4) };
                                unsafe {
                                    let flags0 = _lower1;
                                    *_param_ptr.add(0).cast::<u8>() = ((flags0.bits() >> 0)
                                        as i32) as u8;
                                }
                                let _param_ptr = unsafe { _ptr.add(8) };
                                unsafe {
                                    let vec0 = (_lower2.into_bytes()).into_boxed_slice();
                                    let ptr0 = vec0.as_ptr().cast::<u8>();
                                    let len0 = vec0.len();
                                    ::core::mem::forget(vec0);
                                    *_param_ptr
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len0;
                                    *_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
                                }
                                let _param_ptr = unsafe {
                                    _ptr.add((8 + 2 * ::core::mem::size_of::<*const u8>()))
                                };
                                unsafe {
                                    let flags0 = _lower3;
                                    *_param_ptr.add(0).cast::<u8>() = ((flags0.bits() >> 0)
                                        as i32) as u8;
                                }
                                let _param_ptr = unsafe {
                                    _ptr.add((9 + 2 * ::core::mem::size_of::<*const u8>()))
                                };
                                unsafe {
                                    let flags0 = _lower4;
                                    *_param_ptr.add(0).cast::<u8>() = ((flags0.bits() >> 0)
                                        as i32) as u8;
                                }
                                (_ptr,)
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = {
                                                let l1 = *_ptr.add(4).cast::<i32>();
                                                Descriptor::from_handle(l1 as u32)
                                            };
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l2 = i32::from(*_ptr.add(4).cast::<u8>());
                                                ErrorCode::_lift(l2 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self, path_flags, path, open_flags, flags))
                            .await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Read the contents of a symbolic link.
                ///
                /// If the contents contain an absolute or rooted path in the underlying
                /// filesystem, this function fails with `error-code::not-permitted`.
                ///
                /// Note: This is similar to `readlinkat` in POSIX.
                #[allow(async_fn_in_trait)]
                pub async fn readlink_at(
                    &self,
                    path: _rt::String,
                ) -> Result<_rt::String, ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a Descriptor, _rt::String);
                            type Results = Result<_rt::String, ErrorCode>;
                            type ParamsLower = (i32, *mut u8, usize);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(
                                    (3 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                )
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.readlink-at"]
                                    fn call(_: i32, _: *mut u8, _: usize, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(
                                    _: i32,
                                    _: *mut u8,
                                    _: usize,
                                    _: *mut u8,
                                ) -> i32 {
                                    unreachable!()
                                }
                                unsafe {
                                    call(_params.0, _params.1, _params.2, _results) as u32
                                }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {
                                    _rt::cabi_dealloc(_params.1, _params.2, 1);
                                }
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {
                                    _rt::cabi_dealloc(_params.1, _params.2, 1);
                                }
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe {
                                    let vec0 = (_lower1.into_bytes()).into_boxed_slice();
                                    let ptr0 = vec0.as_ptr().cast::<u8>();
                                    let len0 = vec0.len();
                                    ::core::mem::forget(vec0);
                                    ((_lower0).handle() as i32, ptr0.cast_mut(), len0)
                                }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = {
                                                let l1 = *_ptr
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l2 = *_ptr
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len3 = l2;
                                                let bytes3 = _rt::Vec::from_raw_parts(
                                                    l1.cast(),
                                                    len3,
                                                    len3,
                                                );
                                                _rt::string_lift(bytes3)
                                            };
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l4 = i32::from(
                                                    *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                                );
                                                ErrorCode::_lift(l4 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self, path)).await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Remove a directory.
                ///
                /// Return `error-code::not-empty` if the directory is not empty.
                ///
                /// Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.
                #[allow(async_fn_in_trait)]
                pub async fn remove_directory_at(
                    &self,
                    path: _rt::String,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a Descriptor, _rt::String);
                            type Results = Result<(), ErrorCode>;
                            type ParamsLower = (i32, *mut u8, usize);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(2, 1)
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.remove-directory-at"]
                                    fn call(_: i32, _: *mut u8, _: usize, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(
                                    _: i32,
                                    _: *mut u8,
                                    _: usize,
                                    _: *mut u8,
                                ) -> i32 {
                                    unreachable!()
                                }
                                unsafe {
                                    call(_params.0, _params.1, _params.2, _results) as u32
                                }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {
                                    _rt::cabi_dealloc(_params.1, _params.2, 1);
                                }
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {
                                    _rt::cabi_dealloc(_params.1, _params.2, 1);
                                }
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe {
                                    let vec0 = (_lower1.into_bytes()).into_boxed_slice();
                                    let ptr0 = vec0.as_ptr().cast::<u8>();
                                    let len0 = vec0.len();
                                    ::core::mem::forget(vec0);
                                    ((_lower0).handle() as i32, ptr0.cast_mut(), len0)
                                }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = ();
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(1).cast::<u8>());
                                                ErrorCode::_lift(l1 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self, path)).await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Rename a filesystem object.
                ///
                /// Note: This is similar to `renameat` in POSIX.
                #[allow(async_fn_in_trait)]
                pub async fn rename_at(
                    &self,
                    old_path: _rt::String,
                    new_descriptor: &Descriptor,
                    new_path: _rt::String,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (
                                &'a Descriptor,
                                _rt::String,
                                &'a Descriptor,
                                _rt::String,
                            );
                            type Results = Result<(), ErrorCode>;
                            type ParamsLower = (*mut u8,);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(
                                    (7 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                )
                            };
                            const RESULTS_OFFSET: usize = (6
                                * ::core::mem::size_of::<*const u8>());
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.rename-at"]
                                    fn call(_: *mut u8, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(_: *mut u8, _: *mut u8) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {
                                    let l0 = *_params
                                        .0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l1 = *_params
                                        .0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l0, l1, 1);
                                    let l2 = *_params
                                        .0
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l3 = *_params
                                        .0
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {
                                    let l0 = *_params
                                        .0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l1 = *_params
                                        .0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l0, l1, 1);
                                    let l2 = *_params
                                        .0
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l3 = *_params
                                        .0
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1, _lower2, _lower3): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                let _param_ptr = unsafe { _ptr.add(0) };
                                unsafe {
                                    *_param_ptr.add(0).cast::<i32>() = (_lower0).handle()
                                        as i32;
                                }
                                let _param_ptr = unsafe {
                                    _ptr.add(::core::mem::size_of::<*const u8>())
                                };
                                unsafe {
                                    let vec0 = (_lower1.into_bytes()).into_boxed_slice();
                                    let ptr0 = vec0.as_ptr().cast::<u8>();
                                    let len0 = vec0.len();
                                    ::core::mem::forget(vec0);
                                    *_param_ptr
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len0;
                                    *_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
                                }
                                let _param_ptr = unsafe {
                                    _ptr.add((3 * ::core::mem::size_of::<*const u8>()))
                                };
                                unsafe {
                                    *_param_ptr.add(0).cast::<i32>() = (_lower2).handle()
                                        as i32;
                                }
                                let _param_ptr = unsafe {
                                    _ptr.add((4 * ::core::mem::size_of::<*const u8>()))
                                };
                                unsafe {
                                    let vec0 = (_lower3.into_bytes()).into_boxed_slice();
                                    let ptr0 = vec0.as_ptr().cast::<u8>();
                                    let len0 = vec0.len();
                                    ::core::mem::forget(vec0);
                                    *_param_ptr
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len0;
                                    *_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
                                }
                                (_ptr,)
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = ();
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(1).cast::<u8>());
                                                ErrorCode::_lift(l1 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self, old_path, new_descriptor, new_path))
                            .await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Create a symbolic link (also known as a "symlink").
                ///
                /// If `old-path` starts with `/`, the function fails with
                /// `error-code::not-permitted`.
                ///
                /// Note: This is similar to `symlinkat` in POSIX.
                #[allow(async_fn_in_trait)]
                pub async fn symlink_at(
                    &self,
                    old_path: _rt::String,
                    new_path: _rt::String,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a Descriptor, _rt::String, _rt::String);
                            type Results = Result<(), ErrorCode>;
                            type ParamsLower = (*mut u8,);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(
                                    (6 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                )
                            };
                            const RESULTS_OFFSET: usize = (5
                                * ::core::mem::size_of::<*const u8>());
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.symlink-at"]
                                    fn call(_: *mut u8, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(_: *mut u8, _: *mut u8) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {
                                    let l0 = *_params
                                        .0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l1 = *_params
                                        .0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l0, l1, 1);
                                    let l2 = *_params
                                        .0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l3 = *_params
                                        .0
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {
                                    let l0 = *_params
                                        .0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l1 = *_params
                                        .0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l0, l1, 1);
                                    let l2 = *_params
                                        .0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l3 = *_params
                                        .0
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1, _lower2): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                let _param_ptr = unsafe { _ptr.add(0) };
                                unsafe {
                                    *_param_ptr.add(0).cast::<i32>() = (_lower0).handle()
                                        as i32;
                                }
                                let _param_ptr = unsafe {
                                    _ptr.add(::core::mem::size_of::<*const u8>())
                                };
                                unsafe {
                                    let vec0 = (_lower1.into_bytes()).into_boxed_slice();
                                    let ptr0 = vec0.as_ptr().cast::<u8>();
                                    let len0 = vec0.len();
                                    ::core::mem::forget(vec0);
                                    *_param_ptr
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len0;
                                    *_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
                                }
                                let _param_ptr = unsafe {
                                    _ptr.add((3 * ::core::mem::size_of::<*const u8>()))
                                };
                                unsafe {
                                    let vec0 = (_lower2.into_bytes()).into_boxed_slice();
                                    let ptr0 = vec0.as_ptr().cast::<u8>();
                                    let len0 = vec0.len();
                                    ::core::mem::forget(vec0);
                                    *_param_ptr
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len0;
                                    *_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
                                }
                                (_ptr,)
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = ();
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(1).cast::<u8>());
                                                ErrorCode::_lift(l1 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self, old_path, new_path)).await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Unlink a filesystem object that is not a directory.
                ///
                /// Return `error-code::is-directory` if the path refers to a directory.
                /// Note: This is similar to `unlinkat(fd, path, 0)` in POSIX.
                #[allow(async_fn_in_trait)]
                pub async fn unlink_file_at(
                    &self,
                    path: _rt::String,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a Descriptor, _rt::String);
                            type Results = Result<(), ErrorCode>;
                            type ParamsLower = (i32, *mut u8, usize);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(2, 1)
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.unlink-file-at"]
                                    fn call(_: i32, _: *mut u8, _: usize, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(
                                    _: i32,
                                    _: *mut u8,
                                    _: usize,
                                    _: *mut u8,
                                ) -> i32 {
                                    unreachable!()
                                }
                                unsafe {
                                    call(_params.0, _params.1, _params.2, _results) as u32
                                }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {
                                    _rt::cabi_dealloc(_params.1, _params.2, 1);
                                }
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {
                                    _rt::cabi_dealloc(_params.1, _params.2, 1);
                                }
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe {
                                    let vec0 = (_lower1.into_bytes()).into_boxed_slice();
                                    let ptr0 = vec0.as_ptr().cast::<u8>();
                                    let len0 = vec0.len();
                                    ::core::mem::forget(vec0);
                                    ((_lower0).handle() as i32, ptr0.cast_mut(), len0)
                                }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = ();
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(1).cast::<u8>());
                                                ErrorCode::_lift(l1 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self, path)).await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Test whether two descriptors refer to the same filesystem object.
                ///
                /// In POSIX, this corresponds to testing whether the two descriptors have the
                /// same device (`st_dev`) and inode (`st_ino` or `d_ino`) numbers.
                /// wasi-filesystem does not expose device and inode numbers, so this function
                /// may be used instead.
                #[allow(async_fn_in_trait)]
                pub async fn is_same_object(&self, other: &Descriptor) -> bool {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a Descriptor, &'a Descriptor);
                            type Results = bool;
                            type ParamsLower = (i32, i32);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(1, 1)
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.is-same-object"]
                                    fn call(_: i32, _: i32, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(
                                    _: i32,
                                    _: i32,
                                    _: *mut u8,
                                ) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _params.1, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {}
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {}
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe {
                                    ((_lower0).handle() as i32, (_lower1).handle() as i32)
                                }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    _rt::bool_lift(l0 as u8)
                                }
                            }
                        }
                        _MySubtask::call((self, other)).await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Return a hash of the metadata associated with a filesystem object referred
                /// to by a descriptor.
                ///
                /// This returns a hash of the last-modification timestamp and file size, and
                /// may also include the inode number, device number, birth timestamp, and
                /// other metadata fields that may change when the file is modified or
                /// replaced. It may also include a secret value chosen by the
                /// implementation and not otherwise exposed.
                ///
                /// Implementations are encouraged to provide the following properties:
                ///
                ///  - If the file is not modified or replaced, the computed hash value should
                ///    usually not change.
                ///  - If the object is modified or replaced, the computed hash value should
                ///    usually change.
                ///  - The inputs to the hash should not be easily computable from the
                ///    computed hash.
                ///
                /// However, none of these is required.
                #[allow(async_fn_in_trait)]
                pub async fn metadata_hash(
                    &self,
                ) -> Result<MetadataHashValue, ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a Descriptor,);
                            type Results = Result<MetadataHashValue, ErrorCode>;
                            type ParamsLower = (i32,);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(24, 8)
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.metadata-hash"]
                                    fn call(_: i32, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(_: i32, _: *mut u8) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {}
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {}
                            }
                            unsafe fn params_lower(
                                (_lower0,): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe { ((_lower0).handle() as i32,) }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = {
                                                let l1 = *_ptr.add(8).cast::<i64>();
                                                let l2 = *_ptr.add(16).cast::<i64>();
                                                MetadataHashValue {
                                                    lower: l1 as u64,
                                                    upper: l2 as u64,
                                                }
                                            };
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l3 = i32::from(*_ptr.add(8).cast::<u8>());
                                                ErrorCode::_lift(l3 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self,)).await
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                /// Return a hash of the metadata associated with a filesystem object referred
                /// to by a directory descriptor and a relative path.
                ///
                /// This performs the same hash computation as `metadata-hash`.
                #[allow(async_fn_in_trait)]
                pub async fn metadata_hash_at(
                    &self,
                    path_flags: PathFlags,
                    path: _rt::String,
                ) -> Result<MetadataHashValue, ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a Descriptor, PathFlags, _rt::String);
                            type Results = Result<MetadataHashValue, ErrorCode>;
                            type ParamsLower = (i32, i32, *mut u8, usize);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(24, 8)
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]descriptor.metadata-hash-at"]
                                    fn call(
                                        _: i32,
                                        _: i32,
                                        _: *mut u8,
                                        _: usize,
                                        _: *mut u8,
                                    ) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(
                                    _: i32,
                                    _: i32,
                                    _: *mut u8,
                                    _: usize,
                                    _: *mut u8,
                                ) -> i32 {
                                    unreachable!()
                                }
                                unsafe {
                                    call(_params.0, _params.1, _params.2, _params.3, _results)
                                        as u32
                                }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {
                                    _rt::cabi_dealloc(_params.2, _params.3, 1);
                                }
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {
                                    _rt::cabi_dealloc(_params.2, _params.3, 1);
                                }
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1, _lower2): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe {
                                    let flags0 = _lower1;
                                    let vec1 = (_lower2.into_bytes()).into_boxed_slice();
                                    let ptr1 = vec1.as_ptr().cast::<u8>();
                                    let len1 = vec1.len();
                                    ::core::mem::forget(vec1);
                                    (
                                        (_lower0).handle() as i32,
                                        (flags0.bits() >> 0) as i32,
                                        ptr1.cast_mut(),
                                        len1,
                                    )
                                }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = {
                                                let l1 = *_ptr.add(8).cast::<i64>();
                                                let l2 = *_ptr.add(16).cast::<i64>();
                                                MetadataHashValue {
                                                    lower: l1 as u64,
                                                    upper: l2 as u64,
                                                }
                                            };
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l3 = i32::from(*_ptr.add(8).cast::<u8>());
                                                ErrorCode::_lift(l3 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self, path_flags, path)).await
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod preopens {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Descriptor = super::super::super::wasi::filesystem::types::Descriptor;
            #[allow(unused_unsafe, clippy::all)]
            /// Return the set of preopened directories, and their paths.
            #[allow(async_fn_in_trait)]
            pub fn get_directories() -> _rt::Vec<(Descriptor, _rt::String)> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:filesystem/preopens@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "get-directories"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import1(ptr0);
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base8 = l2;
                    let len8 = l3;
                    let mut result8 = _rt::Vec::with_capacity(len8);
                    for i in 0..len8 {
                        let base = base8
                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                        let e8 = {
                            let l4 = *base.add(0).cast::<i32>();
                            let l5 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l6 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len7 = l6;
                            let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                            (
                                super::super::super::wasi::filesystem::types::Descriptor::from_handle(
                                    l4 as u32,
                                ),
                                _rt::string_lift(bytes7),
                            )
                        };
                        result8.push(e8);
                    }
                    _rt::cabi_dealloc(
                        base8,
                        len8 * (3 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result9 = result8;
                    result9
                }
            }
        }
    }
    pub mod random {
        /// WASI Random is a random data API.
        ///
        /// It is intended to be portable at least between Unix-family platforms and
        /// Windows.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod random {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[allow(unused_unsafe, clippy::all)]
            /// Return `len` cryptographically-secure random or pseudo-random bytes.
            ///
            /// This function must produce data at least as cryptographically secure and
            /// fast as an adequately seeded cryptographically-secure pseudo-random
            /// number generator (CSPRNG). It must not block, from the perspective of
            /// the calling program, under any circumstances, including on the first
            /// request and on requests for numbers of bytes. The returned data must
            /// always be unpredictable.
            ///
            /// This function must always return fresh data. Deterministic environments
            /// must omit this function, rather than implementing it with deterministic
            /// data.
            #[allow(async_fn_in_trait)]
            pub fn get_random_bytes(len: u64) -> _rt::Vec<u8> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:random/random@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "get-random-bytes"]
                        fn wit_import1(_: i64, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: i64, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import1(_rt::as_i64(&len), ptr0);
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len4 = l3;
                    let result5 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                    result5
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Return a cryptographically-secure random or pseudo-random `u64` value.
            ///
            /// This function returns the same type of data as `get-random-bytes`,
            /// represented as a `u64`.
            #[allow(async_fn_in_trait)]
            pub fn get_random_u64() -> u64 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:random/random@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "get-random-u64"]
                        fn wit_import0() -> i64;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0() -> i64 {
                        unreachable!()
                    }
                    let ret = wit_import0();
                    ret as u64
                }
            }
        }
        /// The insecure interface for insecure pseudo-random numbers.
        ///
        /// It is intended to be portable at least between Unix-family platforms and
        /// Windows.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod insecure {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[allow(unused_unsafe, clippy::all)]
            /// Return `len` insecure pseudo-random bytes.
            ///
            /// This function is not cryptographically secure. Do not use it for
            /// anything related to security.
            ///
            /// There are no requirements on the values of the returned bytes, however
            /// implementations are encouraged to return evenly distributed values with
            /// a long period.
            #[allow(async_fn_in_trait)]
            pub fn get_insecure_random_bytes(len: u64) -> _rt::Vec<u8> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:random/insecure@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "get-insecure-random-bytes"]
                        fn wit_import1(_: i64, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: i64, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import1(_rt::as_i64(&len), ptr0);
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len4 = l3;
                    let result5 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                    result5
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Return an insecure pseudo-random `u64` value.
            ///
            /// This function returns the same type of pseudo-random data as
            /// `get-insecure-random-bytes`, represented as a `u64`.
            #[allow(async_fn_in_trait)]
            pub fn get_insecure_random_u64() -> u64 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:random/insecure@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "get-insecure-random-u64"]
                        fn wit_import0() -> i64;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0() -> i64 {
                        unreachable!()
                    }
                    let ret = wit_import0();
                    ret as u64
                }
            }
        }
        /// The insecure-seed interface for seeding hash-map DoS resistance.
        ///
        /// It is intended to be portable at least between Unix-family platforms and
        /// Windows.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod insecure_seed {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            #[allow(unused_unsafe, clippy::all)]
            /// Return a 128-bit value that may contain a pseudo-random value.
            ///
            /// The returned value is not required to be computed from a CSPRNG, and may
            /// even be entirely deterministic. Host implementations are encouraged to
            /// provide pseudo-random values to any program exposed to
            /// attacker-controlled content, to enable DoS protection built into many
            /// languages' hash-map implementations.
            ///
            /// This function is intended to only be called once, by a source language
            /// to initialize Denial Of Service (DoS) protection in its hash-map
            /// implementation.
            ///
            /// # Expected future evolution
            ///
            /// This will likely be changed to a value import, to prevent it from being
            /// called multiple times and potentially used for purposes other than DoS
            /// protection.
            #[allow(async_fn_in_trait)]
            pub fn get_insecure_seed() -> (u64, u64) {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:random/insecure-seed@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "get-insecure-seed"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import1(ptr0);
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i64>();
                    let result4 = (l2 as u64, l3 as u64);
                    result4
                }
            }
        }
    }
    pub mod sockets {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Duration = super::super::super::wasi::clocks::monotonic_clock::Duration;
            /// Error codes.
            ///
            /// In theory, every API can return any error code.
            /// In practice, API's typically only return the errors documented per API
            /// combined with a couple of errors that are always possible:
            /// - `unknown`
            /// - `access-denied`
            /// - `not-supported`
            /// - `out-of-memory`
            ///
            /// See each individual API for what the POSIX equivalents are. They sometimes differ per API.
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum ErrorCode {
                /// Unknown error
                Unknown,
                /// Access denied.
                ///
                /// POSIX equivalent: EACCES, EPERM
                AccessDenied,
                /// The operation is not supported.
                ///
                /// POSIX equivalent: EOPNOTSUPP
                NotSupported,
                /// One of the arguments is invalid.
                ///
                /// POSIX equivalent: EINVAL
                InvalidArgument,
                /// Not enough memory to complete the operation.
                ///
                /// POSIX equivalent: ENOMEM, ENOBUFS, EAI_MEMORY
                OutOfMemory,
                /// The operation timed out before it could finish completely.
                Timeout,
                /// The operation is not valid in the socket's current state.
                InvalidState,
                /// A bind operation failed because the provided address is not an address that the `network` can bind to.
                AddressNotBindable,
                /// A bind operation failed because the provided address is already in use or because there are no ephemeral ports available.
                AddressInUse,
                /// The remote address is not reachable
                RemoteUnreachable,
                /// The TCP connection was forcefully rejected
                ConnectionRefused,
                /// The TCP connection was reset.
                ConnectionReset,
                /// A TCP connection was aborted.
                ConnectionAborted,
                /// The size of a datagram sent to a UDP socket exceeded the maximum
                /// supported size.
                DatagramTooLarge,
            }
            impl ErrorCode {
                pub fn name(&self) -> &'static str {
                    match self {
                        ErrorCode::Unknown => "unknown",
                        ErrorCode::AccessDenied => "access-denied",
                        ErrorCode::NotSupported => "not-supported",
                        ErrorCode::InvalidArgument => "invalid-argument",
                        ErrorCode::OutOfMemory => "out-of-memory",
                        ErrorCode::Timeout => "timeout",
                        ErrorCode::InvalidState => "invalid-state",
                        ErrorCode::AddressNotBindable => "address-not-bindable",
                        ErrorCode::AddressInUse => "address-in-use",
                        ErrorCode::RemoteUnreachable => "remote-unreachable",
                        ErrorCode::ConnectionRefused => "connection-refused",
                        ErrorCode::ConnectionReset => "connection-reset",
                        ErrorCode::ConnectionAborted => "connection-aborted",
                        ErrorCode::DatagramTooLarge => "datagram-too-large",
                    }
                }
                pub fn message(&self) -> &'static str {
                    match self {
                        ErrorCode::Unknown => "Unknown error",
                        ErrorCode::AccessDenied => {
                            "Access denied.

          POSIX equivalent: EACCES, EPERM"
                        }
                        ErrorCode::NotSupported => {
                            "The operation is not supported.

          POSIX equivalent: EOPNOTSUPP"
                        }
                        ErrorCode::InvalidArgument => {
                            "One of the arguments is invalid.

          POSIX equivalent: EINVAL"
                        }
                        ErrorCode::OutOfMemory => {
                            "Not enough memory to complete the operation.

          POSIX equivalent: ENOMEM, ENOBUFS, EAI_MEMORY"
                        }
                        ErrorCode::Timeout => {
                            "The operation timed out before it could finish completely."
                        }
                        ErrorCode::InvalidState => {
                            "The operation is not valid in the socket's current state."
                        }
                        ErrorCode::AddressNotBindable => {
                            "A bind operation failed because the provided address is not an address that the `network` can bind to."
                        }
                        ErrorCode::AddressInUse => {
                            "A bind operation failed because the provided address is already in use or because there are no ephemeral ports available."
                        }
                        ErrorCode::RemoteUnreachable => {
                            "The remote address is not reachable"
                        }
                        ErrorCode::ConnectionRefused => {
                            "The TCP connection was forcefully rejected"
                        }
                        ErrorCode::ConnectionReset => "The TCP connection was reset.",
                        ErrorCode::ConnectionAborted => "A TCP connection was aborted.",
                        ErrorCode::DatagramTooLarge => {
                            "The size of a datagram sent to a UDP socket exceeded the maximum
          supported size."
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for ErrorCode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ErrorCode")
                        .field("code", &(*self as i32))
                        .field("name", &self.name())
                        .field("message", &self.message())
                        .finish()
                }
            }
            impl ::core::fmt::Display for ErrorCode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{} (error {})", self.name(), * self as i32)
                }
            }
            impl std::error::Error for ErrorCode {}
            impl ErrorCode {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> ErrorCode {
                    if !cfg!(debug_assertions) {
                        return unsafe { ::core::mem::transmute(val) };
                    }
                    match val {
                        0 => ErrorCode::Unknown,
                        1 => ErrorCode::AccessDenied,
                        2 => ErrorCode::NotSupported,
                        3 => ErrorCode::InvalidArgument,
                        4 => ErrorCode::OutOfMemory,
                        5 => ErrorCode::Timeout,
                        6 => ErrorCode::InvalidState,
                        7 => ErrorCode::AddressNotBindable,
                        8 => ErrorCode::AddressInUse,
                        9 => ErrorCode::RemoteUnreachable,
                        10 => ErrorCode::ConnectionRefused,
                        11 => ErrorCode::ConnectionReset,
                        12 => ErrorCode::ConnectionAborted,
                        13 => ErrorCode::DatagramTooLarge,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum IpAddressFamily {
                /// Similar to `AF_INET` in POSIX.
                Ipv4,
                /// Similar to `AF_INET6` in POSIX.
                Ipv6,
            }
            impl ::core::fmt::Debug for IpAddressFamily {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        IpAddressFamily::Ipv4 => {
                            f.debug_tuple("IpAddressFamily::Ipv4").finish()
                        }
                        IpAddressFamily::Ipv6 => {
                            f.debug_tuple("IpAddressFamily::Ipv6").finish()
                        }
                    }
                }
            }
            impl IpAddressFamily {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> IpAddressFamily {
                    if !cfg!(debug_assertions) {
                        return unsafe { ::core::mem::transmute(val) };
                    }
                    match val {
                        0 => IpAddressFamily::Ipv4,
                        1 => IpAddressFamily::Ipv6,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            pub type Ipv4Address = (u8, u8, u8, u8);
            pub type Ipv6Address = (u16, u16, u16, u16, u16, u16, u16, u16);
            #[derive(Clone, Copy)]
            pub enum IpAddress {
                Ipv4(Ipv4Address),
                Ipv6(Ipv6Address),
            }
            impl ::core::fmt::Debug for IpAddress {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        IpAddress::Ipv4(e) => {
                            f.debug_tuple("IpAddress::Ipv4").field(e).finish()
                        }
                        IpAddress::Ipv6(e) => {
                            f.debug_tuple("IpAddress::Ipv6").field(e).finish()
                        }
                    }
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Ipv4SocketAddress {
                /// sin_port
                pub port: u16,
                /// sin_addr
                pub address: Ipv4Address,
            }
            impl ::core::fmt::Debug for Ipv4SocketAddress {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Ipv4SocketAddress")
                        .field("port", &self.port)
                        .field("address", &self.address)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Ipv6SocketAddress {
                /// sin6_port
                pub port: u16,
                /// sin6_flowinfo
                pub flow_info: u32,
                /// sin6_addr
                pub address: Ipv6Address,
                /// sin6_scope_id
                pub scope_id: u32,
            }
            impl ::core::fmt::Debug for Ipv6SocketAddress {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Ipv6SocketAddress")
                        .field("port", &self.port)
                        .field("flow-info", &self.flow_info)
                        .field("address", &self.address)
                        .field("scope-id", &self.scope_id)
                        .finish()
                }
            }
            #[derive(Clone, Copy)]
            pub enum IpSocketAddress {
                Ipv4(Ipv4SocketAddress),
                Ipv6(Ipv6SocketAddress),
            }
            impl ::core::fmt::Debug for IpSocketAddress {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        IpSocketAddress::Ipv4(e) => {
                            f.debug_tuple("IpSocketAddress::Ipv4").field(e).finish()
                        }
                        IpSocketAddress::Ipv6(e) => {
                            f.debug_tuple("IpSocketAddress::Ipv6").field(e).finish()
                        }
                    }
                }
            }
            /// A TCP socket resource.
            ///
            /// The socket can be in one of the following states:
            /// - `unbound`
            /// - `bound` (See note below)
            /// - `listening`
            /// - `connecting`
            /// - `connected`
            /// - `closed`
            /// See <https://github.com/WebAssembly/wasi-sockets/blob/main/TcpSocketOperationalSemantics-0.3.0-draft.md>
            /// for more information.
            ///
            /// Note: Except where explicitly mentioned, whenever this documentation uses
            /// the term "bound" without backticks it actually means: in the `bound` state *or higher*.
            /// (i.e. `bound`, `listening`, `connecting` or `connected`)
            ///
            /// In addition to the general error codes documented on the
            /// `types::error-code` type, TCP socket methods may always return
            /// `error(invalid-state)` when in the `closed` state.
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct TcpSocket {
                handle: _rt::Resource<TcpSocket>,
            }
            impl TcpSocket {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for TcpSocket {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "[resource-drop]tcp-socket"]
                        fn drop(_: i32);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn drop(_: i32) {
                        unreachable!()
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
            /// A UDP socket handle.
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct UdpSocket {
                handle: _rt::Resource<UdpSocket>,
            }
            impl UdpSocket {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for UdpSocket {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[link_name = "[resource-drop]udp-socket"]
                        fn drop(_: i32);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn drop(_: i32) {
                        unreachable!()
                    }
                    unsafe {
                        drop(_handle as i32);
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Create a new TCP socket.
                ///
                /// Similar to `socket(AF_INET or AF_INET6, SOCK_STREAM, IPPROTO_TCP)` in POSIX.
                /// On IPv6 sockets, IPV6_V6ONLY is enabled by default and can't be configured otherwise.
                ///
                /// Unlike POSIX, WASI sockets have no notion of a socket-level
                /// `O_NONBLOCK` flag. Instead they fully rely on the Component Model's
                /// async support.
                ///
                /// # References
                /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
                /// - <https://man7.org/linux/man-pages/man2/socket.2.html>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
                /// - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
                #[allow(async_fn_in_trait)]
                pub fn create(
                    address_family: IpAddressFamily,
                ) -> Result<TcpSocket, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[static]tcp-socket.create"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1(address_family.clone() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    TcpSocket::from_handle(l3 as u32)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Bind the socket to the provided IP address and port.
                ///
                /// If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which
                /// network interface(s) to bind to.
                /// If the TCP/UDP port is zero, the socket will be bound to a random free port.
                ///
                /// Bind can be attempted multiple times on the same socket, even with
                /// different arguments on each iteration. But never concurrently and
                /// only as long as the previous bind failed. Once a bind succeeds, the
                /// binding can't be changed anymore.
                ///
                /// # Typical errors
                /// - `invalid-argument`:          The `local-address` has the wrong address family. (EAFNOSUPPORT, EFAULT on Windows)
                /// - `invalid-argument`:          `local-address` is not a unicast address. (EINVAL)
                /// - `invalid-argument`:          `local-address` is an IPv4-mapped IPv6 address. (EINVAL)
                /// - `invalid-state`:             The socket is already bound. (EINVAL)
                /// - `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
                /// - `address-in-use`:            Address is already in use. (EADDRINUSE)
                /// - `address-not-bindable`:      `local-address` is not an address that can be bound to. (EADDRNOTAVAIL)
                ///
                /// # Implementors note
                /// When binding to a non-zero port, this bind operation shouldn't be affected by the TIME_WAIT
                /// state of a recently closed socket on the same local address. In practice this means that the SO_REUSEADDR
                /// socket option should be set implicitly on all platforms, except on Windows where this is the default behavior
                /// and SO_REUSEADDR performs something different entirely.
                ///
                /// # References
                /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
                /// - <https://man7.org/linux/man-pages/man2/bind.2.html>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
                /// - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
                #[allow(async_fn_in_trait)]
                pub fn bind(
                    &self,
                    local_address: IpSocketAddress,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let (
                            result4_0,
                            result4_1,
                            result4_2,
                            result4_3,
                            result4_4,
                            result4_5,
                            result4_6,
                            result4_7,
                            result4_8,
                            result4_9,
                            result4_10,
                            result4_11,
                        ) = match local_address {
                            IpSocketAddress::Ipv4(e) => {
                                let Ipv4SocketAddress { port: port0, address: address0 } = e;
                                let (t1_0, t1_1, t1_2, t1_3) = address0;
                                (
                                    0i32,
                                    _rt::as_i32(port0),
                                    _rt::as_i32(t1_0),
                                    _rt::as_i32(t1_1),
                                    _rt::as_i32(t1_2),
                                    _rt::as_i32(t1_3),
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                )
                            }
                            IpSocketAddress::Ipv6(e) => {
                                let Ipv6SocketAddress {
                                    port: port2,
                                    flow_info: flow_info2,
                                    address: address2,
                                    scope_id: scope_id2,
                                } = e;
                                let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7) = address2;
                                (
                                    1i32,
                                    _rt::as_i32(port2),
                                    _rt::as_i32(flow_info2),
                                    _rt::as_i32(t3_0),
                                    _rt::as_i32(t3_1),
                                    _rt::as_i32(t3_2),
                                    _rt::as_i32(t3_3),
                                    _rt::as_i32(t3_4),
                                    _rt::as_i32(t3_5),
                                    _rt::as_i32(t3_6),
                                    _rt::as_i32(t3_7),
                                    _rt::as_i32(scope_id2),
                                )
                            }
                        };
                        let ptr5 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.bind"]
                            fn wit_import6(
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import6(
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        wit_import6(
                            (self).handle() as i32,
                            result4_0,
                            result4_1,
                            result4_2,
                            result4_3,
                            result4_4,
                            result4_5,
                            result4_6,
                            result4_7,
                            result4_8,
                            result4_9,
                            result4_10,
                            result4_11,
                            ptr5,
                        );
                        let l7 = i32::from(*ptr5.add(0).cast::<u8>());
                        let result9 = match l7 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l8 = i32::from(*ptr5.add(1).cast::<u8>());
                                    ErrorCode::_lift(l8 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result9
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Connect to a remote endpoint.
                ///
                /// On success, the socket is transitioned into the `connected` state and this function returns a connection resource.
                ///
                /// After a failed connection attempt, the socket will be in the `closed`
                /// state and the only valid action left is to `drop` the socket. A single
                /// socket can not be used to connect more than once.
                ///
                /// # Typical errors
                /// - `invalid-argument`:          The `remote-address` has the wrong address family. (EAFNOSUPPORT)
                /// - `invalid-argument`:          `remote-address` is not a unicast address. (EINVAL, ENETUNREACH on Linux, EAFNOSUPPORT on MacOS)
                /// - `invalid-argument`:          `remote-address` is an IPv4-mapped IPv6 address. (EINVAL, EADDRNOTAVAIL on Illumos)
                /// - `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EADDRNOTAVAIL on Windows)
                /// - `invalid-argument`:          The port in `remote-address` is set to 0. (EADDRNOTAVAIL on Windows)
                /// - `invalid-state`:             The socket is already in the `connecting` state. (EALREADY)
                /// - `invalid-state`:             The socket is already in the `connected` state. (EISCONN)
                /// - `invalid-state`:             The socket is already in the `listening` state. (EOPNOTSUPP, EINVAL on Windows)
                /// - `timeout`:                   Connection timed out. (ETIMEDOUT)
                /// - `connection-refused`:        The connection was forcefully rejected. (ECONNREFUSED)
                /// - `connection-reset`:          The connection was reset. (ECONNRESET)
                /// - `connection-aborted`:        The connection was aborted. (ECONNABORTED)
                /// - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
                /// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
                ///
                /// # References
                /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
                /// - <https://man7.org/linux/man-pages/man2/connect.2.html>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
                /// - <https://man.freebsd.org/cgi/man.cgi?connect>
                #[allow(async_fn_in_trait)]
                pub async fn connect(
                    &self,
                    remote_address: IpSocketAddress,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a TcpSocket, IpSocketAddress);
                            type Results = Result<(), ErrorCode>;
                            type ParamsLower = (*mut u8,);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(40, 4)
                            };
                            const RESULTS_OFFSET: usize = 36;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]tcp-socket.connect"]
                                    fn call(_: *mut u8, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(_: *mut u8, _: *mut u8) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {}
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {}
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                let _param_ptr = unsafe { _ptr.add(0) };
                                unsafe {
                                    *_param_ptr.add(0).cast::<i32>() = (_lower0).handle()
                                        as i32;
                                }
                                let _param_ptr = unsafe { _ptr.add(4) };
                                unsafe {
                                    match _lower1 {
                                        IpSocketAddress::Ipv4(e) => {
                                            *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
                                            let Ipv4SocketAddress { port: port0, address: address0 } = e;
                                            *_param_ptr.add(4).cast::<u16>() = (_rt::as_i32(port0))
                                                as u16;
                                            let (t1_0, t1_1, t1_2, t1_3) = address0;
                                            *_param_ptr.add(6).cast::<u8>() = (_rt::as_i32(t1_0)) as u8;
                                            *_param_ptr.add(7).cast::<u8>() = (_rt::as_i32(t1_1)) as u8;
                                            *_param_ptr.add(8).cast::<u8>() = (_rt::as_i32(t1_2)) as u8;
                                            *_param_ptr.add(9).cast::<u8>() = (_rt::as_i32(t1_3)) as u8;
                                        }
                                        IpSocketAddress::Ipv6(e) => {
                                            *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
                                            let Ipv6SocketAddress {
                                                port: port2,
                                                flow_info: flow_info2,
                                                address: address2,
                                                scope_id: scope_id2,
                                            } = e;
                                            *_param_ptr.add(4).cast::<u16>() = (_rt::as_i32(port2))
                                                as u16;
                                            *_param_ptr.add(8).cast::<i32>() = _rt::as_i32(flow_info2);
                                            let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7) = address2;
                                            *_param_ptr.add(12).cast::<u16>() = (_rt::as_i32(t3_0))
                                                as u16;
                                            *_param_ptr.add(14).cast::<u16>() = (_rt::as_i32(t3_1))
                                                as u16;
                                            *_param_ptr.add(16).cast::<u16>() = (_rt::as_i32(t3_2))
                                                as u16;
                                            *_param_ptr.add(18).cast::<u16>() = (_rt::as_i32(t3_3))
                                                as u16;
                                            *_param_ptr.add(20).cast::<u16>() = (_rt::as_i32(t3_4))
                                                as u16;
                                            *_param_ptr.add(22).cast::<u16>() = (_rt::as_i32(t3_5))
                                                as u16;
                                            *_param_ptr.add(24).cast::<u16>() = (_rt::as_i32(t3_6))
                                                as u16;
                                            *_param_ptr.add(26).cast::<u16>() = (_rt::as_i32(t3_7))
                                                as u16;
                                            *_param_ptr.add(28).cast::<i32>() = _rt::as_i32(scope_id2);
                                        }
                                    }
                                }
                                (_ptr,)
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = ();
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(1).cast::<u8>());
                                                ErrorCode::_lift(l1 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self, remote_address)).await
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Start listening and return a stream of new inbound connections.
                ///
                /// Transitions the socket into the `listening` state. This can be called
                /// at most once per socket.
                ///
                /// If the socket is not already explicitly bound, this function will
                /// implicitly bind the socket to a random free port.
                ///
                /// Normally, the returned sockets are bound, in the `connected` state
                /// and immediately ready for I/O. Though, depending on exact timing and
                /// circumstances, a newly accepted connection may already be `closed`
                /// by the time the server attempts to perform its first I/O on it. This
                /// is true regardless of whether the WASI implementation uses
                /// "synthesized" sockets or not (see Implementors Notes below).
                ///
                /// The following properties are inherited from the listener socket:
                /// - `address-family`
                /// - `keep-alive-enabled`
                /// - `keep-alive-idle-time`
                /// - `keep-alive-interval`
                /// - `keep-alive-count`
                /// - `hop-limit`
                /// - `receive-buffer-size`
                /// - `send-buffer-size`
                ///
                /// # Typical errors
                /// - `invalid-state`:             The socket is already in the `connected` state. (EISCONN, EINVAL on BSD)
                /// - `invalid-state`:             The socket is already in the `listening` state.
                /// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE)
                ///
                /// # Implementors note
                /// This method returns a single perpetual stream that should only close
                /// on fatal errors (if any). Yet, the POSIX' `accept` function may also
                /// return transient errors (e.g. ECONNABORTED). The exact details differ
                /// per operation system. For example, the Linux manual mentions:
                ///
                /// > Linux accept() passes already-pending network errors on the new
                /// > socket as an error code from accept(). This behavior differs from
                /// > other BSD socket implementations. For reliable operation the
                /// > application should detect the network errors defined for the
                /// > protocol after accept() and treat them like EAGAIN by retrying.
                /// > In the case of TCP/IP, these are ENETDOWN, EPROTO, ENOPROTOOPT,
                /// > EHOSTDOWN, ENONET, EHOSTUNREACH, EOPNOTSUPP, and ENETUNREACH.
                /// Source: https://man7.org/linux/man-pages/man2/accept.2.html
                ///
                /// WASI implementations have two options to handle this:
                /// - Optionally log it and then skip over non-fatal errors returned by
                ///   `accept`. Guest code never gets to see these failures. Or:
                /// - Synthesize a `tcp-socket` resource that exposes the error when
                ///   attempting to send or receive on it. Guest code then sees these
                ///   failures as regular I/O errors.
                ///
                /// In either case, the stream returned by this `listen` method remains
                /// operational.
                ///
                /// # References
                /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html>
                /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/accept.html>
                /// - <https://man7.org/linux/man-pages/man2/listen.2.html>
                /// - <https://man7.org/linux/man-pages/man2/accept.2.html>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept>
                /// - <https://man.freebsd.org/cgi/man.cgi?query=listen&sektion=2>
                /// - <https://man.freebsd.org/cgi/man.cgi?query=accept&sektion=2>
                #[allow(async_fn_in_trait)]
                pub fn listen(
                    &self,
                ) -> Result<
                    wit_bindgen::rt::async_support::StreamReader<TcpSocket>,
                    ErrorCode,
                > {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.listen"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    wit_bindgen::rt::async_support::StreamReader::new(
                                        l3 as u32,
                                        &super::super::super::wit_stream::vtable2::VTABLE,
                                    )
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Transmit data to peer.
                ///
                /// The caller should close the stream when it has no more data to send
                /// to the peer. Under normal circumstances this will cause a FIN packet
                /// to be sent out. Closing the stream is equivalent to calling
                /// `shutdown(SHUT_WR)` in POSIX.
                ///
                /// This function may be called at most once and returns once the full
                /// contents of the stream are transmitted or an error is encountered.
                ///
                /// # Typical errors
                /// - `invalid-state`:             The socket is not in the `connected` state. (ENOTCONN)
                /// - `connection-reset`:          The connection was reset. (ECONNRESET)
                /// - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
                ///
                ///  # References
                /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/send.html>
                /// - <https://man7.org/linux/man-pages/man2/send.2.html>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send>
                /// - <https://man.freebsd.org/cgi/man.cgi?query=send&sektion=2>
                #[allow(async_fn_in_trait)]
                pub async fn send(
                    &self,
                    data: wit_bindgen::rt::async_support::StreamReader<u8>,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (
                                &'a TcpSocket,
                                wit_bindgen::rt::async_support::StreamReader<u8>,
                            );
                            type Results = Result<(), ErrorCode>;
                            type ParamsLower = (i32, i32);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(2, 1)
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]tcp-socket.send"]
                                    fn call(_: i32, _: i32, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(
                                    _: i32,
                                    _: i32,
                                    _: *mut u8,
                                ) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _params.1, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {}
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {
                                    let _ = wit_bindgen::rt::async_support::StreamReader::new(
                                        _params.1 as u32,
                                        &super::super::super::wit_stream::vtable0::VTABLE,
                                    );
                                }
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe {
                                    ((_lower0).handle() as i32, (_lower1).take_handle() as i32)
                                }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = ();
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(1).cast::<u8>());
                                                ErrorCode::_lift(l1 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self, data)).await
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Read data from peer.
                ///
                /// This function returns a `stream` which provides the data received from the
                /// socket, and a `future` providing additional error information in case the
                /// socket is closed abnormally.
                ///
                /// If the socket is closed normally, `stream.read` on the `stream` will return
                /// `read-status::closed` with no `error-context` and the future resolves to
                /// the value `ok`. If the socket is closed abnormally, `stream.read` on the
                /// `stream` returns `read-status::closed` with an `error-context` and the future
                /// resolves to `err` with an `error-code`.
                ///
                /// `receive` is meant to be called only once per socket. If it is called more
                /// than once, the subsequent calls return a new `stream` that fails as if it
                /// were closed abnormally.
                ///
                /// If the caller is not expecting to receive any data from the peer,
                /// they may drop the stream. Any data still in the receive queue
                /// will be discarded. This is equivalent to calling `shutdown(SHUT_RD)`
                /// in POSIX.
                ///
                /// # Typical errors
                /// - `invalid-state`:             The socket is not in the `connected` state. (ENOTCONN)
                /// - `connection-reset`:          The connection was reset. (ECONNRESET)
                /// - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
                ///
                /// # References
                /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recv.html>
                /// - <https://man7.org/linux/man-pages/man2/recv.2.html>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv>
                /// - <https://man.freebsd.org/cgi/man.cgi?query=recv&sektion=2>
                #[allow(async_fn_in_trait)]
                pub fn receive(
                    &self,
                ) -> (
                    wit_bindgen::rt::async_support::StreamReader<u8>,
                    wit_bindgen::rt::async_support::FutureReader<Result<(), ErrorCode>>,
                ) {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.receive"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = *ptr0.add(0).cast::<i32>();
                        let l3 = *ptr0.add(4).cast::<i32>();
                        let result4 = (
                            wit_bindgen::rt::async_support::StreamReader::new(
                                l2 as u32,
                                &super::super::super::wit_stream::vtable0::VTABLE,
                            ),
                            wit_bindgen::rt::async_support::FutureReader::new(
                                l3 as u32,
                                &super::super::super::wit_future::vtable1::VTABLE,
                            ),
                        );
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Get the bound local address.
                ///
                /// POSIX mentions:
                /// > If the socket has not been bound to a local name, the value
                /// > stored in the object pointed to by `address` is unspecified.
                ///
                /// WASI is stricter and requires `get-local-address` to return `invalid-state` when the socket hasn't been bound yet.
                ///
                /// # Typical errors
                /// - `invalid-state`: The socket is not bound to any local address.
                ///
                /// # References
                /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
                /// - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
                /// - <https://man.freebsd.org/cgi/man.cgi?getsockname>
                #[allow(async_fn_in_trait)]
                pub fn get_local_address(&self) -> Result<IpSocketAddress, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 36]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 36],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.get-local-address"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result22 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    let v20 = match l3 {
                                        0 => {
                                            let e20 = {
                                                let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                                                let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                                                let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                                                let l8 = i32::from(*ptr0.add(13).cast::<u8>());
                                                Ipv4SocketAddress {
                                                    port: l4 as u16,
                                                    address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                                                }
                                            };
                                            IpSocketAddress::Ipv4(e20)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            let e20 = {
                                                let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l10 = *ptr0.add(12).cast::<i32>();
                                                let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                                                let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                                                let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                                                let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                                                let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                                                let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                                                let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                                                let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                                                let l19 = *ptr0.add(32).cast::<i32>();
                                                Ipv6SocketAddress {
                                                    port: l9 as u16,
                                                    flow_info: l10 as u32,
                                                    address: (
                                                        l11 as u16,
                                                        l12 as u16,
                                                        l13 as u16,
                                                        l14 as u16,
                                                        l15 as u16,
                                                        l16 as u16,
                                                        l17 as u16,
                                                        l18 as u16,
                                                    ),
                                                    scope_id: l19 as u32,
                                                }
                                            };
                                            IpSocketAddress::Ipv6(e20)
                                        }
                                    };
                                    v20
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l21 = i32::from(*ptr0.add(4).cast::<u8>());
                                    ErrorCode::_lift(l21 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result22
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Get the remote address.
                ///
                /// # Typical errors
                /// - `invalid-state`: The socket is not connected to a remote address. (ENOTCONN)
                ///
                /// # References
                /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
                /// - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
                /// - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
                #[allow(async_fn_in_trait)]
                pub fn get_remote_address(&self) -> Result<IpSocketAddress, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 36]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 36],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.get-remote-address"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result22 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    let v20 = match l3 {
                                        0 => {
                                            let e20 = {
                                                let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                                                let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                                                let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                                                let l8 = i32::from(*ptr0.add(13).cast::<u8>());
                                                Ipv4SocketAddress {
                                                    port: l4 as u16,
                                                    address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                                                }
                                            };
                                            IpSocketAddress::Ipv4(e20)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            let e20 = {
                                                let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l10 = *ptr0.add(12).cast::<i32>();
                                                let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                                                let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                                                let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                                                let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                                                let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                                                let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                                                let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                                                let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                                                let l19 = *ptr0.add(32).cast::<i32>();
                                                Ipv6SocketAddress {
                                                    port: l9 as u16,
                                                    flow_info: l10 as u32,
                                                    address: (
                                                        l11 as u16,
                                                        l12 as u16,
                                                        l13 as u16,
                                                        l14 as u16,
                                                        l15 as u16,
                                                        l16 as u16,
                                                        l17 as u16,
                                                        l18 as u16,
                                                    ),
                                                    scope_id: l19 as u32,
                                                }
                                            };
                                            IpSocketAddress::Ipv6(e20)
                                        }
                                    };
                                    v20
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l21 = i32::from(*ptr0.add(4).cast::<u8>());
                                    ErrorCode::_lift(l21 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result22
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Whether the socket is in the `listening` state.
                ///
                /// Equivalent to the SO_ACCEPTCONN socket option.
                #[allow(async_fn_in_trait)]
                pub fn get_is_listening(&self) -> bool {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.get-is-listening"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = wit_import0((self).handle() as i32);
                        _rt::bool_lift(ret as u8)
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Whether this is a IPv4 or IPv6 socket.
                ///
                /// This is the value passed to the constructor.
                ///
                /// Equivalent to the SO_DOMAIN socket option.
                #[allow(async_fn_in_trait)]
                pub fn get_address_family(&self) -> IpAddressFamily {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.get-address-family"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = wit_import0((self).handle() as i32);
                        IpAddressFamily::_lift(ret as u8)
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Hints the desired listen queue size. Implementations are free to ignore this.
                ///
                /// If the provided value is 0, an `invalid-argument` error is returned.
                /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
                ///
                /// # Typical errors
                /// - `not-supported`:        (set) The platform does not support changing the backlog size after the initial listen.
                /// - `invalid-argument`:     (set) The provided value was 0.
                /// - `invalid-state`:        (set) The socket is in the `connecting` or `connected` state.
                #[allow(async_fn_in_trait)]
                pub fn set_listen_backlog_size(
                    &self,
                    value: u64,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.set-listen-backlog-size"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Enables or disables keepalive.
                ///
                /// The keepalive behavior can be adjusted using:
                /// - `keep-alive-idle-time`
                /// - `keep-alive-interval`
                /// - `keep-alive-count`
                /// These properties can be configured while `keep-alive-enabled` is false, but only come into effect when `keep-alive-enabled` is true.
                ///
                /// Equivalent to the SO_KEEPALIVE socket option.
                #[allow(async_fn_in_trait)]
                pub fn get_keep_alive_enabled(&self) -> Result<bool, ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.get-keep-alive-enabled"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    _rt::bool_lift(l3 as u8)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_keep_alive_enabled(
                    &self,
                    value: bool,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.set-keep-alive-enabled"]
                            fn wit_import1(_: i32, _: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1(
                            (self).handle() as i32,
                            match &value {
                                true => 1,
                                false => 0,
                            },
                            ptr0,
                        );
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Amount of time the connection has to be idle before TCP starts sending keepalive packets.
                ///
                /// If the provided value is 0, an `invalid-argument` error is returned.
                /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
                /// I.e. after setting a value, reading the same setting back may return a different value.
                ///
                /// Equivalent to the TCP_KEEPIDLE socket option. (TCP_KEEPALIVE on MacOS)
                ///
                /// # Typical errors
                /// - `invalid-argument`:     (set) The provided value was 0.
                #[allow(async_fn_in_trait)]
                pub fn get_keep_alive_idle_time(&self) -> Result<Duration, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.get-keep-alive-idle-time"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_keep_alive_idle_time(
                    &self,
                    value: Duration,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.set-keep-alive-idle-time"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// The time between keepalive packets.
                ///
                /// If the provided value is 0, an `invalid-argument` error is returned.
                /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
                /// I.e. after setting a value, reading the same setting back may return a different value.
                ///
                /// Equivalent to the TCP_KEEPINTVL socket option.
                ///
                /// # Typical errors
                /// - `invalid-argument`:     (set) The provided value was 0.
                #[allow(async_fn_in_trait)]
                pub fn get_keep_alive_interval(&self) -> Result<Duration, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.get-keep-alive-interval"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_keep_alive_interval(
                    &self,
                    value: Duration,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.set-keep-alive-interval"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// The maximum amount of keepalive packets TCP should send before aborting the connection.
                ///
                /// If the provided value is 0, an `invalid-argument` error is returned.
                /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
                /// I.e. after setting a value, reading the same setting back may return a different value.
                ///
                /// Equivalent to the TCP_KEEPCNT socket option.
                ///
                /// # Typical errors
                /// - `invalid-argument`:     (set) The provided value was 0.
                #[allow(async_fn_in_trait)]
                pub fn get_keep_alive_count(&self) -> Result<u32, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.get-keep-alive-count"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    l3 as u32
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_keep_alive_count(&self, value: u32) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.set-keep-alive-count"]
                            fn wit_import1(_: i32, _: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, _rt::as_i32(&value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
                ///
                /// If the provided value is 0, an `invalid-argument` error is returned.
                ///
                /// # Typical errors
                /// - `invalid-argument`:     (set) The TTL value must be 1 or higher.
                #[allow(async_fn_in_trait)]
                pub fn get_hop_limit(&self) -> Result<u8, ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.get-hop-limit"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    l3 as u8
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_hop_limit(&self, value: u8) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.set-hop-limit"]
                            fn wit_import1(_: i32, _: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, _rt::as_i32(&value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// The kernel buffer space reserved for sends/receives on this socket.
                ///
                /// If the provided value is 0, an `invalid-argument` error is returned.
                /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
                /// I.e. after setting a value, reading the same setting back may return a different value.
                ///
                /// Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
                ///
                /// # Typical errors
                /// - `invalid-argument`:     (set) The provided value was 0.
                #[allow(async_fn_in_trait)]
                pub fn get_receive_buffer_size(&self) -> Result<u64, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.get-receive-buffer-size"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_receive_buffer_size(
                    &self,
                    value: u64,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.set-receive-buffer-size"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn get_send_buffer_size(&self) -> Result<u64, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.get-send-buffer-size"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_send_buffer_size(&self, value: u64) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.set-send-buffer-size"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Create a new UDP socket.
                ///
                /// Similar to `socket(AF_INET or AF_INET6, SOCK_DGRAM, IPPROTO_UDP)` in POSIX.
                /// On IPv6 sockets, IPV6_V6ONLY is enabled by default and can't be configured otherwise.
                ///
                /// Unlike POSIX, WASI sockets have no notion of a socket-level
                /// `O_NONBLOCK` flag. Instead they fully rely on the Component Model's
                /// async support.
                ///
                /// # References:
                /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
                /// - <https://man7.org/linux/man-pages/man2/socket.2.html>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
                /// - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
                #[allow(async_fn_in_trait)]
                pub fn create(
                    address_family: IpAddressFamily,
                ) -> Result<UdpSocket, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[static]udp-socket.create"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1(address_family.clone() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    UdpSocket::from_handle(l3 as u32)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Bind the socket to the provided IP address and port.
                ///
                /// If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which
                /// network interface(s) to bind to.
                /// If the port is zero, the socket will be bound to a random free port.
                ///
                /// # Typical errors
                /// - `invalid-argument`:          The `local-address` has the wrong address family. (EAFNOSUPPORT, EFAULT on Windows)
                /// - `invalid-state`:             The socket is already bound. (EINVAL)
                /// - `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
                /// - `address-in-use`:            Address is already in use. (EADDRINUSE)
                /// - `address-not-bindable`:      `local-address` is not an address that can be bound to. (EADDRNOTAVAIL)
                ///
                /// # References
                /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
                /// - <https://man7.org/linux/man-pages/man2/bind.2.html>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
                /// - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
                #[allow(async_fn_in_trait)]
                pub fn bind(
                    &self,
                    local_address: IpSocketAddress,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let (
                            result4_0,
                            result4_1,
                            result4_2,
                            result4_3,
                            result4_4,
                            result4_5,
                            result4_6,
                            result4_7,
                            result4_8,
                            result4_9,
                            result4_10,
                            result4_11,
                        ) = match local_address {
                            IpSocketAddress::Ipv4(e) => {
                                let Ipv4SocketAddress { port: port0, address: address0 } = e;
                                let (t1_0, t1_1, t1_2, t1_3) = address0;
                                (
                                    0i32,
                                    _rt::as_i32(port0),
                                    _rt::as_i32(t1_0),
                                    _rt::as_i32(t1_1),
                                    _rt::as_i32(t1_2),
                                    _rt::as_i32(t1_3),
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                )
                            }
                            IpSocketAddress::Ipv6(e) => {
                                let Ipv6SocketAddress {
                                    port: port2,
                                    flow_info: flow_info2,
                                    address: address2,
                                    scope_id: scope_id2,
                                } = e;
                                let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7) = address2;
                                (
                                    1i32,
                                    _rt::as_i32(port2),
                                    _rt::as_i32(flow_info2),
                                    _rt::as_i32(t3_0),
                                    _rt::as_i32(t3_1),
                                    _rt::as_i32(t3_2),
                                    _rt::as_i32(t3_3),
                                    _rt::as_i32(t3_4),
                                    _rt::as_i32(t3_5),
                                    _rt::as_i32(t3_6),
                                    _rt::as_i32(t3_7),
                                    _rt::as_i32(scope_id2),
                                )
                            }
                        };
                        let ptr5 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.bind"]
                            fn wit_import6(
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import6(
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        wit_import6(
                            (self).handle() as i32,
                            result4_0,
                            result4_1,
                            result4_2,
                            result4_3,
                            result4_4,
                            result4_5,
                            result4_6,
                            result4_7,
                            result4_8,
                            result4_9,
                            result4_10,
                            result4_11,
                            ptr5,
                        );
                        let l7 = i32::from(*ptr5.add(0).cast::<u8>());
                        let result9 = match l7 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l8 = i32::from(*ptr5.add(1).cast::<u8>());
                                    ErrorCode::_lift(l8 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result9
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Associate this socket with a specific peer address.
                ///
                /// On success, the `remote-address` of the socket is updated.
                /// The `local-address` may be updated as well, based on the best network
                /// path to `remote-address`. If the socket was not already explicitly
                /// bound, this function will implicitly bind the socket to a random
                /// free port.
                ///
                /// When a UDP socket is "connected", the `send` and `receive` methods
                /// are limited to communicating with that peer only:
                /// - `send` can only be used to send to this destination.
                /// - `receive` will only return datagrams sent from the provided `remote-address`.
                ///
                /// The name "connect" was kept to align with the existing POSIX
                /// terminology. Other than that, this function only changes the local
                /// socket configuration and does not generate any network traffic.
                /// The peer is not aware of this "connection".
                ///
                /// This method may be called multiple times on the same socket to change
                /// its association, but only the most recent one will be effective.
                ///
                /// # Typical errors
                /// - `invalid-argument`:          The `remote-address` has the wrong address family. (EAFNOSUPPORT)
                /// - `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
                /// - `invalid-argument`:          The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
                /// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
                ///
                /// # Implementors note
                /// If the socket is already connected, some platforms (e.g. Linux)
                /// require a disconnect before connecting to a different peer address.
                ///
                /// # References
                /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
                /// - <https://man7.org/linux/man-pages/man2/connect.2.html>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
                /// - <https://man.freebsd.org/cgi/man.cgi?connect>
                #[allow(async_fn_in_trait)]
                pub fn connect(
                    &self,
                    remote_address: IpSocketAddress,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let (
                            result4_0,
                            result4_1,
                            result4_2,
                            result4_3,
                            result4_4,
                            result4_5,
                            result4_6,
                            result4_7,
                            result4_8,
                            result4_9,
                            result4_10,
                            result4_11,
                        ) = match remote_address {
                            IpSocketAddress::Ipv4(e) => {
                                let Ipv4SocketAddress { port: port0, address: address0 } = e;
                                let (t1_0, t1_1, t1_2, t1_3) = address0;
                                (
                                    0i32,
                                    _rt::as_i32(port0),
                                    _rt::as_i32(t1_0),
                                    _rt::as_i32(t1_1),
                                    _rt::as_i32(t1_2),
                                    _rt::as_i32(t1_3),
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                )
                            }
                            IpSocketAddress::Ipv6(e) => {
                                let Ipv6SocketAddress {
                                    port: port2,
                                    flow_info: flow_info2,
                                    address: address2,
                                    scope_id: scope_id2,
                                } = e;
                                let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7) = address2;
                                (
                                    1i32,
                                    _rt::as_i32(port2),
                                    _rt::as_i32(flow_info2),
                                    _rt::as_i32(t3_0),
                                    _rt::as_i32(t3_1),
                                    _rt::as_i32(t3_2),
                                    _rt::as_i32(t3_3),
                                    _rt::as_i32(t3_4),
                                    _rt::as_i32(t3_5),
                                    _rt::as_i32(t3_6),
                                    _rt::as_i32(t3_7),
                                    _rt::as_i32(scope_id2),
                                )
                            }
                        };
                        let ptr5 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.connect"]
                            fn wit_import6(
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import6(
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        wit_import6(
                            (self).handle() as i32,
                            result4_0,
                            result4_1,
                            result4_2,
                            result4_3,
                            result4_4,
                            result4_5,
                            result4_6,
                            result4_7,
                            result4_8,
                            result4_9,
                            result4_10,
                            result4_11,
                            ptr5,
                        );
                        let l7 = i32::from(*ptr5.add(0).cast::<u8>());
                        let result9 = match l7 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l8 = i32::from(*ptr5.add(1).cast::<u8>());
                                    ErrorCode::_lift(l8 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result9
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Dissociate this socket from its peer address.
                ///
                /// After calling this method, `send` & `receive` are free to communicate
                /// with any address again.
                ///
                /// The POSIX equivalent of this is calling `connect` with an `AF_UNSPEC` address.
                ///
                /// # Typical errors
                /// - `invalid-state`:           The socket is not connected.
                ///
                /// # References
                /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
                /// - <https://man7.org/linux/man-pages/man2/connect.2.html>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
                /// - <https://man.freebsd.org/cgi/man.cgi?connect>
                #[allow(async_fn_in_trait)]
                pub fn disconnect(&self) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.disconnect"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Send a message on the socket to a particular peer.
                ///
                /// If the socket is connected, the peer address may be left empty. In
                /// that case this is equivalent to `send` in POSIX. Otherwise it is
                /// equivalent to `sendto`.
                ///
                /// Additionally, if the socket is connected, a `remote-address` argument
                /// _may_ be provided but then it must be identical to the address
                /// passed to `connect`.
                ///
                /// Implementations may trap if the `data` length exceeds 64 KiB.
                ///
                /// # Typical errors
                /// - `invalid-argument`:        The `remote-address` has the wrong address family. (EAFNOSUPPORT)
                /// - `invalid-argument`:        The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
                /// - `invalid-argument`:        The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
                /// - `invalid-argument`:        The socket is in "connected" mode and `remote-address` is `some` value that does not match the address passed to `connect`. (EISCONN)
                /// - `invalid-argument`:        The socket is not "connected" and no value for `remote-address` was provided. (EDESTADDRREQ)
                /// - `remote-unreachable`:      The remote address is not reachable. (ECONNRESET, ENETRESET on Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
                /// - `connection-refused`:      The connection was refused. (ECONNREFUSED)
                /// - `datagram-too-large`:      The datagram is too large. (EMSGSIZE)
                ///
                /// # References
                /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendto.html>
                /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendmsg.html>
                /// - <https://man7.org/linux/man-pages/man2/send.2.html>
                /// - <https://man7.org/linux/man-pages/man2/sendmmsg.2.html>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-sendto>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasendmsg>
                /// - <https://man.freebsd.org/cgi/man.cgi?query=send&sektion=2>
                #[allow(async_fn_in_trait)]
                pub async fn send(
                    &self,
                    data: _rt::Vec<u8>,
                    remote_address: Option<IpSocketAddress>,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (
                                &'a UdpSocket,
                                _rt::Vec<u8>,
                                Option<IpSocketAddress>,
                            );
                            type Results = Result<(), ErrorCode>;
                            type ParamsLower = (*mut u8,);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(
                                    (40 + 3 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                )
                            };
                            const RESULTS_OFFSET: usize = (36
                                + 3 * ::core::mem::size_of::<*const u8>());
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]udp-socket.send"]
                                    fn call(_: *mut u8, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(_: *mut u8, _: *mut u8) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {
                                    let l0 = *_params
                                        .0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l1 = *_params
                                        .0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base2 = l0;
                                    let len2 = l1;
                                    _rt::cabi_dealloc(base2, len2 * 1, 1);
                                }
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {
                                    let l0 = *_params
                                        .0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l1 = *_params
                                        .0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base2 = l0;
                                    let len2 = l1;
                                    _rt::cabi_dealloc(base2, len2 * 1, 1);
                                }
                            }
                            unsafe fn params_lower(
                                (_lower0, _lower1, _lower2): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                let _param_ptr = unsafe { _ptr.add(0) };
                                unsafe {
                                    *_param_ptr.add(0).cast::<i32>() = (_lower0).handle()
                                        as i32;
                                }
                                let _param_ptr = unsafe {
                                    _ptr.add(::core::mem::size_of::<*const u8>())
                                };
                                unsafe {
                                    let vec0 = (_lower1).into_boxed_slice();
                                    let ptr0 = vec0.as_ptr().cast::<u8>();
                                    let len0 = vec0.len();
                                    ::core::mem::forget(vec0);
                                    *_param_ptr
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len0;
                                    *_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
                                }
                                let _param_ptr = unsafe {
                                    _ptr.add((3 * ::core::mem::size_of::<*const u8>()))
                                };
                                unsafe {
                                    match _lower2 {
                                        Some(e) => {
                                            *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
                                            match e {
                                                IpSocketAddress::Ipv4(e) => {
                                                    *_param_ptr.add(4).cast::<u8>() = (0i32) as u8;
                                                    let Ipv4SocketAddress { port: port0, address: address0 } = e;
                                                    *_param_ptr.add(8).cast::<u16>() = (_rt::as_i32(port0))
                                                        as u16;
                                                    let (t1_0, t1_1, t1_2, t1_3) = address0;
                                                    *_param_ptr.add(10).cast::<u8>() = (_rt::as_i32(t1_0))
                                                        as u8;
                                                    *_param_ptr.add(11).cast::<u8>() = (_rt::as_i32(t1_1))
                                                        as u8;
                                                    *_param_ptr.add(12).cast::<u8>() = (_rt::as_i32(t1_2))
                                                        as u8;
                                                    *_param_ptr.add(13).cast::<u8>() = (_rt::as_i32(t1_3))
                                                        as u8;
                                                }
                                                IpSocketAddress::Ipv6(e) => {
                                                    *_param_ptr.add(4).cast::<u8>() = (1i32) as u8;
                                                    let Ipv6SocketAddress {
                                                        port: port2,
                                                        flow_info: flow_info2,
                                                        address: address2,
                                                        scope_id: scope_id2,
                                                    } = e;
                                                    *_param_ptr.add(8).cast::<u16>() = (_rt::as_i32(port2))
                                                        as u16;
                                                    *_param_ptr.add(12).cast::<i32>() = _rt::as_i32(flow_info2);
                                                    let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7) = address2;
                                                    *_param_ptr.add(16).cast::<u16>() = (_rt::as_i32(t3_0))
                                                        as u16;
                                                    *_param_ptr.add(18).cast::<u16>() = (_rt::as_i32(t3_1))
                                                        as u16;
                                                    *_param_ptr.add(20).cast::<u16>() = (_rt::as_i32(t3_2))
                                                        as u16;
                                                    *_param_ptr.add(22).cast::<u16>() = (_rt::as_i32(t3_3))
                                                        as u16;
                                                    *_param_ptr.add(24).cast::<u16>() = (_rt::as_i32(t3_4))
                                                        as u16;
                                                    *_param_ptr.add(26).cast::<u16>() = (_rt::as_i32(t3_5))
                                                        as u16;
                                                    *_param_ptr.add(28).cast::<u16>() = (_rt::as_i32(t3_6))
                                                        as u16;
                                                    *_param_ptr.add(30).cast::<u16>() = (_rt::as_i32(t3_7))
                                                        as u16;
                                                    *_param_ptr.add(32).cast::<i32>() = _rt::as_i32(scope_id2);
                                                }
                                            }
                                        }
                                        None => {
                                            *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                                (_ptr,)
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = ();
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l1 = i32::from(*_ptr.add(1).cast::<u8>());
                                                ErrorCode::_lift(l1 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self, data, remote_address)).await
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Receive a message on the socket.
                ///
                /// On success, the return value contains a tuple of the received data
                /// and the address of the sender. Theoretical maximum length of the
                /// data is 64 KiB. Though in practice, it will typically be less than
                /// 1500 bytes.
                ///
                /// If the socket is connected, the sender address is guaranteed to
                /// match the remote address passed to `connect`.
                ///
                /// # Typical errors
                /// - `invalid-state`:        The socket has not been bound yet.
                /// - `remote-unreachable`:   The remote address is not reachable. (ECONNRESET, ENETRESET on Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
                /// - `connection-refused`:   The connection was refused. (ECONNREFUSED)
                ///
                /// # References
                /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvfrom.html>
                /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvmsg.html>
                /// - <https://man7.org/linux/man-pages/man2/recv.2.html>
                /// - <https://man7.org/linux/man-pages/man2/recvmmsg.2.html>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recvfrom>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg>
                /// - <https://man.freebsd.org/cgi/man.cgi?query=recv&sektion=2>
                #[allow(async_fn_in_trait)]
                pub async fn receive(
                    &self,
                ) -> Result<(_rt::Vec<u8>, IpSocketAddress), ErrorCode> {
                    unsafe {
                        use wit_bindgen::rt::async_support::Subtask as _Subtask;
                        struct _MySubtask<'a> {
                            _unused: &'a (),
                        }
                        #[allow(unused_parens)]
                        unsafe impl<'a> _Subtask for _MySubtask<'a> {
                            type Params = (&'a UdpSocket,);
                            type Results = Result<
                                (_rt::Vec<u8>, IpSocketAddress),
                                ErrorCode,
                            >;
                            type ParamsLower = (i32,);
                            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                                ::core::alloc::Layout::from_size_align_unchecked(
                                    (32 + 3 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                )
                            };
                            const RESULTS_OFFSET: usize = 0;
                            unsafe fn call_import(
                                _params: Self::ParamsLower,
                                _results: *mut u8,
                            ) -> u32 {
                                #[cfg(target_arch = "wasm32")]
                                #[link(
                                    wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                                )]
                                unsafe extern "C" {
                                    #[link_name = "[async-lower][async method]udp-socket.receive"]
                                    fn call(_: i32, _: *mut u8) -> i32;
                                }
                                #[cfg(not(target_arch = "wasm32"))]
                                unsafe extern "C" fn call(_: i32, _: *mut u8) -> i32 {
                                    unreachable!()
                                }
                                unsafe { call(_params.0, _results) as u32 }
                            }
                            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                                unsafe {}
                            }
                            unsafe fn params_dealloc_lists_and_own(
                                _params: Self::ParamsLower,
                            ) {
                                unsafe {}
                            }
                            unsafe fn params_lower(
                                (_lower0,): Self::Params,
                                _ptr: *mut u8,
                            ) -> Self::ParamsLower {
                                unsafe { ((_lower0).handle() as i32,) }
                            }
                            unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                                unsafe {
                                    let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                    match l0 {
                                        0 => {
                                            let e = {
                                                let l1 = *_ptr
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l2 = *_ptr
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len3 = l2;
                                                let l4 = i32::from(
                                                    *_ptr
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                let v21 = match l4 {
                                                    0 => {
                                                        let e21 = {
                                                            let l5 = i32::from(
                                                                *_ptr
                                                                    .add(4 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u16>(),
                                                            );
                                                            let l6 = i32::from(
                                                                *_ptr
                                                                    .add(6 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u8>(),
                                                            );
                                                            let l7 = i32::from(
                                                                *_ptr
                                                                    .add(7 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u8>(),
                                                            );
                                                            let l8 = i32::from(
                                                                *_ptr
                                                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u8>(),
                                                            );
                                                            let l9 = i32::from(
                                                                *_ptr
                                                                    .add(9 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u8>(),
                                                            );
                                                            Ipv4SocketAddress {
                                                                port: l5 as u16,
                                                                address: (l6 as u8, l7 as u8, l8 as u8, l9 as u8),
                                                            }
                                                        };
                                                        IpSocketAddress::Ipv4(e21)
                                                    }
                                                    n => {
                                                        debug_assert_eq!(n, 1, "invalid enum discriminant");
                                                        let e21 = {
                                                            let l10 = i32::from(
                                                                *_ptr
                                                                    .add(4 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u16>(),
                                                            );
                                                            let l11 = *_ptr
                                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<i32>();
                                                            let l12 = i32::from(
                                                                *_ptr
                                                                    .add(12 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u16>(),
                                                            );
                                                            let l13 = i32::from(
                                                                *_ptr
                                                                    .add(14 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u16>(),
                                                            );
                                                            let l14 = i32::from(
                                                                *_ptr
                                                                    .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u16>(),
                                                            );
                                                            let l15 = i32::from(
                                                                *_ptr
                                                                    .add(18 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u16>(),
                                                            );
                                                            let l16 = i32::from(
                                                                *_ptr
                                                                    .add(20 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u16>(),
                                                            );
                                                            let l17 = i32::from(
                                                                *_ptr
                                                                    .add(22 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u16>(),
                                                            );
                                                            let l18 = i32::from(
                                                                *_ptr
                                                                    .add(24 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u16>(),
                                                            );
                                                            let l19 = i32::from(
                                                                *_ptr
                                                                    .add(26 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u16>(),
                                                            );
                                                            let l20 = *_ptr
                                                                .add(28 + 3 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<i32>();
                                                            Ipv6SocketAddress {
                                                                port: l10 as u16,
                                                                flow_info: l11 as u32,
                                                                address: (
                                                                    l12 as u16,
                                                                    l13 as u16,
                                                                    l14 as u16,
                                                                    l15 as u16,
                                                                    l16 as u16,
                                                                    l17 as u16,
                                                                    l18 as u16,
                                                                    l19 as u16,
                                                                ),
                                                                scope_id: l20 as u32,
                                                            }
                                                        };
                                                        IpSocketAddress::Ipv6(e21)
                                                    }
                                                };
                                                (_rt::Vec::from_raw_parts(l1.cast(), len3, len3), v21)
                                            };
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = {
                                                let l22 = i32::from(
                                                    *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                                );
                                                ErrorCode::_lift(l22 as u8)
                                            };
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                }
                            }
                        }
                        _MySubtask::call((self,)).await
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Get the current bound address.
                ///
                /// POSIX mentions:
                /// > If the socket has not been bound to a local name, the value
                /// > stored in the object pointed to by `address` is unspecified.
                ///
                /// WASI is stricter and requires `get-local-address` to return `invalid-state` when the socket hasn't been bound yet.
                ///
                /// # Typical errors
                /// - `invalid-state`: The socket is not bound to any local address.
                ///
                /// # References
                /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
                /// - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
                /// - <https://man.freebsd.org/cgi/man.cgi?getsockname>
                #[allow(async_fn_in_trait)]
                pub fn get_local_address(&self) -> Result<IpSocketAddress, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 36]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 36],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.get-local-address"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result22 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    let v20 = match l3 {
                                        0 => {
                                            let e20 = {
                                                let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                                                let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                                                let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                                                let l8 = i32::from(*ptr0.add(13).cast::<u8>());
                                                Ipv4SocketAddress {
                                                    port: l4 as u16,
                                                    address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                                                }
                                            };
                                            IpSocketAddress::Ipv4(e20)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            let e20 = {
                                                let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l10 = *ptr0.add(12).cast::<i32>();
                                                let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                                                let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                                                let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                                                let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                                                let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                                                let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                                                let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                                                let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                                                let l19 = *ptr0.add(32).cast::<i32>();
                                                Ipv6SocketAddress {
                                                    port: l9 as u16,
                                                    flow_info: l10 as u32,
                                                    address: (
                                                        l11 as u16,
                                                        l12 as u16,
                                                        l13 as u16,
                                                        l14 as u16,
                                                        l15 as u16,
                                                        l16 as u16,
                                                        l17 as u16,
                                                        l18 as u16,
                                                    ),
                                                    scope_id: l19 as u32,
                                                }
                                            };
                                            IpSocketAddress::Ipv6(e20)
                                        }
                                    };
                                    v20
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l21 = i32::from(*ptr0.add(4).cast::<u8>());
                                    ErrorCode::_lift(l21 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result22
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Get the address the socket is currently "connected" to.
                ///
                /// # Typical errors
                /// - `invalid-state`: The socket is not "connected" to a specific remote address. (ENOTCONN)
                ///
                /// # References
                /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
                /// - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
                /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
                /// - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
                #[allow(async_fn_in_trait)]
                pub fn get_remote_address(&self) -> Result<IpSocketAddress, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 36]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 36],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.get-remote-address"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result22 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    let v20 = match l3 {
                                        0 => {
                                            let e20 = {
                                                let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                                                let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                                                let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                                                let l8 = i32::from(*ptr0.add(13).cast::<u8>());
                                                Ipv4SocketAddress {
                                                    port: l4 as u16,
                                                    address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                                                }
                                            };
                                            IpSocketAddress::Ipv4(e20)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            let e20 = {
                                                let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l10 = *ptr0.add(12).cast::<i32>();
                                                let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                                                let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                                                let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                                                let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                                                let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                                                let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                                                let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                                                let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                                                let l19 = *ptr0.add(32).cast::<i32>();
                                                Ipv6SocketAddress {
                                                    port: l9 as u16,
                                                    flow_info: l10 as u32,
                                                    address: (
                                                        l11 as u16,
                                                        l12 as u16,
                                                        l13 as u16,
                                                        l14 as u16,
                                                        l15 as u16,
                                                        l16 as u16,
                                                        l17 as u16,
                                                        l18 as u16,
                                                    ),
                                                    scope_id: l19 as u32,
                                                }
                                            };
                                            IpSocketAddress::Ipv6(e20)
                                        }
                                    };
                                    v20
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l21 = i32::from(*ptr0.add(4).cast::<u8>());
                                    ErrorCode::_lift(l21 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result22
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Whether this is a IPv4 or IPv6 socket.
                ///
                /// This is the value passed to the constructor.
                ///
                /// Equivalent to the SO_DOMAIN socket option.
                #[allow(async_fn_in_trait)]
                pub fn get_address_family(&self) -> IpAddressFamily {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.get-address-family"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = wit_import0((self).handle() as i32);
                        IpAddressFamily::_lift(ret as u8)
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
                ///
                /// If the provided value is 0, an `invalid-argument` error is returned.
                ///
                /// # Typical errors
                /// - `invalid-argument`:     (set) The TTL value must be 1 or higher.
                #[allow(async_fn_in_trait)]
                pub fn get_unicast_hop_limit(&self) -> Result<u8, ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.get-unicast-hop-limit"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    l3 as u8
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_unicast_hop_limit(&self, value: u8) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.set-unicast-hop-limit"]
                            fn wit_import1(_: i32, _: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, _rt::as_i32(&value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                /// The kernel buffer space reserved for sends/receives on this socket.
                ///
                /// If the provided value is 0, an `invalid-argument` error is returned.
                /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
                /// I.e. after setting a value, reading the same setting back may return a different value.
                ///
                /// Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
                ///
                /// # Typical errors
                /// - `invalid-argument`:     (set) The provided value was 0.
                #[allow(async_fn_in_trait)]
                pub fn get_receive_buffer_size(&self) -> Result<u64, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.get-receive-buffer-size"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_receive_buffer_size(
                    &self,
                    value: u64,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.set-receive-buffer-size"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn get_send_buffer_size(&self) -> Result<u64, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.get-send-buffer-size"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set_send_buffer_size(&self, value: u64) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.set-send-buffer-size"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod ip_name_lookup {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type IpAddress = super::super::super::wasi::sockets::types::IpAddress;
            /// Lookup error codes.
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum ErrorCode {
                /// Unknown error
                Unknown,
                /// Access denied.
                ///
                /// POSIX equivalent: EACCES, EPERM
                AccessDenied,
                /// `name` is a syntactically invalid domain name or IP address.
                ///
                /// POSIX equivalent: EINVAL
                InvalidArgument,
                /// Name does not exist or has no suitable associated IP addresses.
                ///
                /// POSIX equivalent: EAI_NONAME, EAI_NODATA, EAI_ADDRFAMILY
                NameUnresolvable,
                /// A temporary failure in name resolution occurred.
                ///
                /// POSIX equivalent: EAI_AGAIN
                TemporaryResolverFailure,
                /// A permanent failure in name resolution occurred.
                ///
                /// POSIX equivalent: EAI_FAIL
                PermanentResolverFailure,
            }
            impl ErrorCode {
                pub fn name(&self) -> &'static str {
                    match self {
                        ErrorCode::Unknown => "unknown",
                        ErrorCode::AccessDenied => "access-denied",
                        ErrorCode::InvalidArgument => "invalid-argument",
                        ErrorCode::NameUnresolvable => "name-unresolvable",
                        ErrorCode::TemporaryResolverFailure => {
                            "temporary-resolver-failure"
                        }
                        ErrorCode::PermanentResolverFailure => {
                            "permanent-resolver-failure"
                        }
                    }
                }
                pub fn message(&self) -> &'static str {
                    match self {
                        ErrorCode::Unknown => "Unknown error",
                        ErrorCode::AccessDenied => {
                            "Access denied.

        POSIX equivalent: EACCES, EPERM"
                        }
                        ErrorCode::InvalidArgument => {
                            "`name` is a syntactically invalid domain name or IP address.

        POSIX equivalent: EINVAL"
                        }
                        ErrorCode::NameUnresolvable => {
                            "Name does not exist or has no suitable associated IP addresses.

        POSIX equivalent: EAI_NONAME, EAI_NODATA, EAI_ADDRFAMILY"
                        }
                        ErrorCode::TemporaryResolverFailure => {
                            "A temporary failure in name resolution occurred.

        POSIX equivalent: EAI_AGAIN"
                        }
                        ErrorCode::PermanentResolverFailure => {
                            "A permanent failure in name resolution occurred.

        POSIX equivalent: EAI_FAIL"
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for ErrorCode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ErrorCode")
                        .field("code", &(*self as i32))
                        .field("name", &self.name())
                        .field("message", &self.message())
                        .finish()
                }
            }
            impl ::core::fmt::Display for ErrorCode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{} (error {})", self.name(), * self as i32)
                }
            }
            impl std::error::Error for ErrorCode {}
            impl ErrorCode {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> ErrorCode {
                    if !cfg!(debug_assertions) {
                        return unsafe { ::core::mem::transmute(val) };
                    }
                    match val {
                        0 => ErrorCode::Unknown,
                        1 => ErrorCode::AccessDenied,
                        2 => ErrorCode::InvalidArgument,
                        3 => ErrorCode::NameUnresolvable,
                        4 => ErrorCode::TemporaryResolverFailure,
                        5 => ErrorCode::PermanentResolverFailure,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Resolve an internet host name to a list of IP addresses.
            ///
            /// Unicode domain names are automatically converted to ASCII using IDNA encoding.
            /// If the input is an IP address string, the address is parsed and returned
            /// as-is without making any external requests.
            ///
            /// See the wasi-socket proposal README.md for a comparison with getaddrinfo.
            ///
            /// The results are returned in connection order preference.
            ///
            /// This function never succeeds with 0 results. It either fails or succeeds
            /// with at least one address. Additionally, this function never returns
            /// IPv4-mapped IPv6 addresses.
            ///
            /// The returned future will resolve to an error code in case of failure.
            /// It will resolve to success once the returned stream is exhausted.
            ///
            /// # References:
            /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getaddrinfo.html>
            /// - <https://man7.org/linux/man-pages/man3/getaddrinfo.3.html>
            /// - <https://learn.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfo>
            /// - <https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&sektion=3>
            #[allow(async_fn_in_trait)]
            pub async fn resolve_addresses(
                name: _rt::String,
            ) -> Result<_rt::Vec<IpAddress>, ErrorCode> {
                unsafe {
                    use wit_bindgen::rt::async_support::Subtask as _Subtask;
                    struct _MySubtask<'a> {
                        _unused: &'a (),
                    }
                    #[allow(unused_parens)]
                    unsafe impl<'a> _Subtask for _MySubtask<'a> {
                        type Params = (_rt::String,);
                        type Results = Result<_rt::Vec<IpAddress>, ErrorCode>;
                        type ParamsLower = (*mut u8, usize);
                        const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                            ::core::alloc::Layout::from_size_align_unchecked(
                                (3 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            )
                        };
                        const RESULTS_OFFSET: usize = 0;
                        unsafe fn call_import(
                            _params: Self::ParamsLower,
                            _results: *mut u8,
                        ) -> u32 {
                            #[cfg(target_arch = "wasm32")]
                            #[link(
                                wasm_import_module = "wasi:sockets/ip-name-lookup@0.3.0-rc-2025-08-15"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[async-lower][async]resolve-addresses"]
                                fn call(_: *mut u8, _: usize, _: *mut u8) -> i32;
                            }
                            #[cfg(not(target_arch = "wasm32"))]
                            unsafe extern "C" fn call(
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            ) -> i32 {
                                unreachable!()
                            }
                            unsafe { call(_params.0, _params.1, _results) as u32 }
                        }
                        unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                            unsafe {
                                _rt::cabi_dealloc(_params.0, _params.1, 1);
                            }
                        }
                        unsafe fn params_dealloc_lists_and_own(
                            _params: Self::ParamsLower,
                        ) {
                            unsafe {
                                _rt::cabi_dealloc(_params.0, _params.1, 1);
                            }
                        }
                        unsafe fn params_lower(
                            (_lower0,): Self::Params,
                            _ptr: *mut u8,
                        ) -> Self::ParamsLower {
                            unsafe {
                                let vec0 = (_lower0.into_bytes()).into_boxed_slice();
                                let ptr0 = vec0.as_ptr().cast::<u8>();
                                let len0 = vec0.len();
                                ::core::mem::forget(vec0);
                                (ptr0.cast_mut(), len0)
                            }
                        }
                        unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
                            unsafe {
                                let l0 = i32::from(*_ptr.add(0).cast::<u8>());
                                match l0 {
                                    0 => {
                                        let e = {
                                            let l1 = *_ptr
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l2 = *_ptr
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let base17 = l1;
                                            let len17 = l2;
                                            let mut result17 = _rt::Vec::with_capacity(len17);
                                            for i in 0..len17 {
                                                let base = base17.add(i * 18);
                                                let e17 = {
                                                    let l3 = i32::from(*base.add(0).cast::<u8>());
                                                    use super::super::super::wasi::sockets::types::IpAddress as V16;
                                                    let v16 = match l3 {
                                                        0 => {
                                                            let e16 = {
                                                                let l4 = i32::from(*base.add(2).cast::<u8>());
                                                                let l5 = i32::from(*base.add(3).cast::<u8>());
                                                                let l6 = i32::from(*base.add(4).cast::<u8>());
                                                                let l7 = i32::from(*base.add(5).cast::<u8>());
                                                                (l4 as u8, l5 as u8, l6 as u8, l7 as u8)
                                                            };
                                                            V16::Ipv4(e16)
                                                        }
                                                        n => {
                                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                                            let e16 = {
                                                                let l8 = i32::from(*base.add(2).cast::<u16>());
                                                                let l9 = i32::from(*base.add(4).cast::<u16>());
                                                                let l10 = i32::from(*base.add(6).cast::<u16>());
                                                                let l11 = i32::from(*base.add(8).cast::<u16>());
                                                                let l12 = i32::from(*base.add(10).cast::<u16>());
                                                                let l13 = i32::from(*base.add(12).cast::<u16>());
                                                                let l14 = i32::from(*base.add(14).cast::<u16>());
                                                                let l15 = i32::from(*base.add(16).cast::<u16>());
                                                                (
                                                                    l8 as u16,
                                                                    l9 as u16,
                                                                    l10 as u16,
                                                                    l11 as u16,
                                                                    l12 as u16,
                                                                    l13 as u16,
                                                                    l14 as u16,
                                                                    l15 as u16,
                                                                )
                                                            };
                                                            V16::Ipv6(e16)
                                                        }
                                                    };
                                                    v16
                                                };
                                                result17.push(e17);
                                            }
                                            _rt::cabi_dealloc(base17, len17 * 18, 2);
                                            result17
                                        };
                                        Ok(e)
                                    }
                                    1 => {
                                        let e = {
                                            let l18 = i32::from(
                                                *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                            );
                                            ErrorCode::_lift(l18 as u8)
                                        };
                                        Err(e)
                                    }
                                    _ => _rt::invalid_enum_discriminant(),
                                }
                            }
                        }
                    }
                    _MySubtask::call((name,)).await
                }
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::vec::Vec;
    pub use alloc_crate::string::String;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            unsafe { String::from_utf8_unchecked(bytes) }
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        unsafe {
            let layout = alloc::Layout::from_size_align_unchecked(size, align);
            alloc::dealloc(ptr, layout);
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    use core::fmt;
    use core::marker;
    use core::sync::atomic::{AtomicU32, Ordering::Relaxed};
    /// A type which represents a component model resource, either imported or
    /// exported into this component.
    ///
    /// This is a low-level wrapper which handles the lifetime of the resource
    /// (namely this has a destructor). The `T` provided defines the component model
    /// intrinsics that this wrapper uses.
    ///
    /// One of the chief purposes of this type is to provide `Deref` implementations
    /// to access the underlying data when it is owned.
    ///
    /// This type is primarily used in generated code for exported and imported
    /// resources.
    #[repr(transparent)]
    pub struct Resource<T: WasmResource> {
        handle: AtomicU32,
        _marker: marker::PhantomData<T>,
    }
    /// A trait which all wasm resources implement, namely providing the ability to
    /// drop a resource.
    ///
    /// This generally is implemented by generated code, not user-facing code.
    #[allow(clippy::missing_safety_doc)]
    pub unsafe trait WasmResource {
        /// Invokes the `[resource-drop]...` intrinsic.
        unsafe fn drop(handle: u32);
    }
    impl<T: WasmResource> Resource<T> {
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
            debug_assert!(handle != 0 && handle != u32::MAX);
            Self {
                handle: AtomicU32::new(handle),
                _marker: marker::PhantomData,
            }
        }
        /// Takes ownership of the handle owned by `resource`.
        ///
        /// Note that this ideally would be `into_handle` taking `Resource<T>` by
        /// ownership. The code generator does not enable that in all situations,
        /// unfortunately, so this is provided instead.
        ///
        /// Also note that `take_handle` is in theory only ever called on values
        /// owned by a generated function. For example a generated function might
        /// take `Resource<T>` as an argument but then call `take_handle` on a
        /// reference to that argument. In that sense the dynamic nature of
        /// `take_handle` should only be exposed internally to generated code, not
        /// to user code.
        #[doc(hidden)]
        pub fn take_handle(resource: &Resource<T>) -> u32 {
            resource.handle.swap(u32::MAX, Relaxed)
        }
        #[doc(hidden)]
        pub fn handle(resource: &Resource<T>) -> u32 {
            resource.handle.load(Relaxed)
        }
    }
    impl<T: WasmResource> fmt::Debug for Resource<T> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Resource").field("handle", &self.handle).finish()
        }
    }
    impl<T: WasmResource> Drop for Resource<T> {
        fn drop(&mut self) {
            unsafe {
                match self.handle.load(Relaxed) {
                    u32::MAX => {}
                    other => T::drop(other),
                }
            }
        }
    }
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    extern crate alloc as alloc_crate;
    pub use alloc_crate::alloc;
}
pub mod wit_future {
    #![allow(dead_code, unused_variables, clippy::all)]
    #[doc(hidden)]
    pub trait FuturePayload: Unpin + Sized + 'static {
        const VTABLE: &'static wit_bindgen::rt::async_support::FutureVtable<Self>;
    }
    #[doc(hidden)]
    #[allow(unused_unsafe)]
    pub mod vtable0 {
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn cancel_write(_: u32) -> u32 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn cancel_read(_: u32) -> u32 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn drop_writable(_: u32) {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn drop_readable(_: u32) {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn new() -> u64 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn start_read(_: u32, _: *mut u8) -> u32 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn start_write(_: u32, _: *const u8) -> u32 {
            unreachable!()
        }
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15")]
        unsafe extern "C" {
            #[link_name = "[future-new-1][method]descriptor.read-via-stream"]
            fn new() -> u64;
            #[link_name = "[future-cancel-write-1][method]descriptor.read-via-stream"]
            fn cancel_write(_: u32) -> u32;
            #[link_name = "[future-cancel-read-1][method]descriptor.read-via-stream"]
            fn cancel_read(_: u32) -> u32;
            #[link_name = "[future-drop-writable-1][method]descriptor.read-via-stream"]
            fn drop_writable(_: u32);
            #[link_name = "[future-drop-readable-1][method]descriptor.read-via-stream"]
            fn drop_readable(_: u32);
            #[link_name = "[async-lower][future-read-1][method]descriptor.read-via-stream"]
            fn start_read(_: u32, _: *mut u8) -> u32;
            #[link_name = "[async-lower][future-write-1][method]descriptor.read-via-stream"]
            fn start_write(_: u32, _: *const u8) -> u32;
        }
        unsafe fn lift(
            ptr: *mut u8,
        ) -> Result<(), super::super::wasi::filesystem::types::ErrorCode> {
            unsafe {
                let l0 = i32::from(*ptr.add(0).cast::<u8>());
                match l0 {
                    0 => {
                        let e = ();
                        Ok(e)
                    }
                    1 => {
                        let e = {
                            let l1 = i32::from(*ptr.add(1).cast::<u8>());
                            super::super::wasi::filesystem::types::ErrorCode::_lift(
                                l1 as u8,
                            )
                        };
                        Err(e)
                    }
                    _ => super::super::_rt::invalid_enum_discriminant(),
                }
            }
        }
        unsafe fn lower(
            value: Result<(), super::super::wasi::filesystem::types::ErrorCode>,
            ptr: *mut u8,
        ) {
            unsafe {
                match value {
                    Ok(_) => {
                        *ptr.add(0).cast::<u8>() = (0i32) as u8;
                    }
                    Err(e) => {
                        *ptr.add(0).cast::<u8>() = (1i32) as u8;
                        *ptr.add(1).cast::<u8>() = (e.clone() as i32) as u8;
                    }
                };
            }
        }
        unsafe fn dealloc_lists(ptr: *mut u8) {
            unsafe {}
        }
        pub static VTABLE: wit_bindgen::rt::async_support::FutureVtable<
            Result<(), super::super::wasi::filesystem::types::ErrorCode>,
        > = wit_bindgen::rt::async_support::FutureVtable::<
            Result<(), super::super::wasi::filesystem::types::ErrorCode>,
        > {
            cancel_write,
            cancel_read,
            drop_writable,
            drop_readable,
            dealloc_lists,
            layout: unsafe { ::std::alloc::Layout::from_size_align_unchecked(2, 1) },
            lift,
            lower,
            new,
            start_read,
            start_write,
        };
        impl super::FuturePayload
        for Result<(), super::super::wasi::filesystem::types::ErrorCode> {
            const VTABLE: &'static wit_bindgen::rt::async_support::FutureVtable<Self> = &VTABLE;
        }
    }
    #[doc(hidden)]
    #[allow(unused_unsafe)]
    pub mod vtable1 {
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn cancel_write(_: u32) -> u32 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn cancel_read(_: u32) -> u32 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn drop_writable(_: u32) {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn drop_readable(_: u32) {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn new() -> u64 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn start_read(_: u32, _: *mut u8) -> u32 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn start_write(_: u32, _: *const u8) -> u32 {
            unreachable!()
        }
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15")]
        unsafe extern "C" {
            #[link_name = "[future-new-1][method]tcp-socket.receive"]
            fn new() -> u64;
            #[link_name = "[future-cancel-write-1][method]tcp-socket.receive"]
            fn cancel_write(_: u32) -> u32;
            #[link_name = "[future-cancel-read-1][method]tcp-socket.receive"]
            fn cancel_read(_: u32) -> u32;
            #[link_name = "[future-drop-writable-1][method]tcp-socket.receive"]
            fn drop_writable(_: u32);
            #[link_name = "[future-drop-readable-1][method]tcp-socket.receive"]
            fn drop_readable(_: u32);
            #[link_name = "[async-lower][future-read-1][method]tcp-socket.receive"]
            fn start_read(_: u32, _: *mut u8) -> u32;
            #[link_name = "[async-lower][future-write-1][method]tcp-socket.receive"]
            fn start_write(_: u32, _: *const u8) -> u32;
        }
        unsafe fn lift(
            ptr: *mut u8,
        ) -> Result<(), super::super::wasi::sockets::types::ErrorCode> {
            unsafe {
                let l0 = i32::from(*ptr.add(0).cast::<u8>());
                match l0 {
                    0 => {
                        let e = ();
                        Ok(e)
                    }
                    1 => {
                        let e = {
                            let l1 = i32::from(*ptr.add(1).cast::<u8>());
                            super::super::wasi::sockets::types::ErrorCode::_lift(
                                l1 as u8,
                            )
                        };
                        Err(e)
                    }
                    _ => super::super::_rt::invalid_enum_discriminant(),
                }
            }
        }
        unsafe fn lower(
            value: Result<(), super::super::wasi::sockets::types::ErrorCode>,
            ptr: *mut u8,
        ) {
            unsafe {
                match value {
                    Ok(_) => {
                        *ptr.add(0).cast::<u8>() = (0i32) as u8;
                    }
                    Err(e) => {
                        *ptr.add(0).cast::<u8>() = (1i32) as u8;
                        *ptr.add(1).cast::<u8>() = (e.clone() as i32) as u8;
                    }
                };
            }
        }
        unsafe fn dealloc_lists(ptr: *mut u8) {
            unsafe {}
        }
        pub static VTABLE: wit_bindgen::rt::async_support::FutureVtable<
            Result<(), super::super::wasi::sockets::types::ErrorCode>,
        > = wit_bindgen::rt::async_support::FutureVtable::<
            Result<(), super::super::wasi::sockets::types::ErrorCode>,
        > {
            cancel_write,
            cancel_read,
            drop_writable,
            drop_readable,
            dealloc_lists,
            layout: unsafe { ::std::alloc::Layout::from_size_align_unchecked(2, 1) },
            lift,
            lower,
            new,
            start_read,
            start_write,
        };
        impl super::FuturePayload
        for Result<(), super::super::wasi::sockets::types::ErrorCode> {
            const VTABLE: &'static wit_bindgen::rt::async_support::FutureVtable<Self> = &VTABLE;
        }
    }
    /// Creates a new Component Model `future` with the specified payload type.
    ///
    /// The `default` function provided computes the default value to be sent in
    /// this future if no other value was otherwise sent.
    pub fn new<T: FuturePayload>(
        default: fn() -> T,
    ) -> (
        wit_bindgen::rt::async_support::FutureWriter<T>,
        wit_bindgen::rt::async_support::FutureReader<T>,
    ) {
        unsafe { wit_bindgen::rt::async_support::future_new::<T>(default, T::VTABLE) }
    }
}
pub mod wit_stream {
    #![allow(dead_code, unused_variables, clippy::all)]
    pub trait StreamPayload: Unpin + Sized + 'static {
        const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self>;
    }
    #[doc(hidden)]
    #[allow(unused_unsafe)]
    pub mod vtable0 {
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn cancel_write(_: u32) -> u32 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn cancel_read(_: u32) -> u32 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn drop_writable(_: u32) {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn drop_readable(_: u32) {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn new() -> u64 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn start_read(_: u32, _: *mut u8, _: usize) -> u32 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn start_write(_: u32, _: *const u8, _: usize) -> u32 {
            unreachable!()
        }
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "wasi:cli/stdin@0.3.0-rc-2025-08-15")]
        unsafe extern "C" {
            #[link_name = "[stream-new-0]get-stdin"]
            fn new() -> u64;
            #[link_name = "[stream-cancel-write-0]get-stdin"]
            fn cancel_write(_: u32) -> u32;
            #[link_name = "[stream-cancel-read-0]get-stdin"]
            fn cancel_read(_: u32) -> u32;
            #[link_name = "[stream-drop-writable-0]get-stdin"]
            fn drop_writable(_: u32);
            #[link_name = "[stream-drop-readable-0]get-stdin"]
            fn drop_readable(_: u32);
            #[link_name = "[async-lower][stream-read-0]get-stdin"]
            fn start_read(_: u32, _: *mut u8, _: usize) -> u32;
            #[link_name = "[async-lower][stream-write-0]get-stdin"]
            fn start_write(_: u32, _: *const u8, _: usize) -> u32;
        }
        pub static VTABLE: wit_bindgen::rt::async_support::StreamVtable<u8> = wit_bindgen::rt::async_support::StreamVtable::<
            u8,
        > {
            cancel_write,
            cancel_read,
            drop_writable,
            drop_readable,
            dealloc_lists: None,
            layout: unsafe { ::std::alloc::Layout::from_size_align_unchecked(1, 1) },
            lift: None,
            lower: None,
            new,
            start_read,
            start_write,
        };
        impl super::StreamPayload for u8 {
            const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self> = &VTABLE;
        }
    }
    #[doc(hidden)]
    #[allow(unused_unsafe)]
    pub mod vtable1 {
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn cancel_write(_: u32) -> u32 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn cancel_read(_: u32) -> u32 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn drop_writable(_: u32) {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn drop_readable(_: u32) {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn new() -> u64 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn start_read(_: u32, _: *mut u8, _: usize) -> u32 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn start_write(_: u32, _: *const u8, _: usize) -> u32 {
            unreachable!()
        }
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "wasi:filesystem/types@0.3.0-rc-2025-08-15")]
        unsafe extern "C" {
            #[link_name = "[stream-new-0][async method]descriptor.read-directory"]
            fn new() -> u64;
            #[link_name = "[stream-cancel-write-0][async method]descriptor.read-directory"]
            fn cancel_write(_: u32) -> u32;
            #[link_name = "[stream-cancel-read-0][async method]descriptor.read-directory"]
            fn cancel_read(_: u32) -> u32;
            #[link_name = "[stream-drop-writable-0][async method]descriptor.read-directory"]
            fn drop_writable(_: u32);
            #[link_name = "[stream-drop-readable-0][async method]descriptor.read-directory"]
            fn drop_readable(_: u32);
            #[link_name = "[async-lower][stream-read-0][async method]descriptor.read-directory"]
            fn start_read(_: u32, _: *mut u8, _: usize) -> u32;
            #[link_name = "[async-lower][stream-write-0][async method]descriptor.read-directory"]
            fn start_write(_: u32, _: *const u8, _: usize) -> u32;
        }
        unsafe fn lift(
            ptr: *mut u8,
        ) -> super::super::wasi::filesystem::types::DirectoryEntry {
            unsafe {
                let l0 = i32::from(*ptr.add(0).cast::<u8>());
                let l1 = *ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l2 = *ptr
                    .add(2 * ::core::mem::size_of::<*const u8>())
                    .cast::<usize>();
                let len3 = l2;
                let bytes3 = super::super::_rt::Vec::from_raw_parts(
                    l1.cast(),
                    len3,
                    len3,
                );
                super::super::wasi::filesystem::types::DirectoryEntry {
                    type_: super::super::wasi::filesystem::types::DescriptorType::_lift(
                        l0 as u8,
                    ),
                    name: super::super::_rt::string_lift(bytes3),
                }
            }
        }
        unsafe fn lower(
            value: super::super::wasi::filesystem::types::DirectoryEntry,
            ptr: *mut u8,
        ) {
            unsafe {
                let super::super::wasi::filesystem::types::DirectoryEntry {
                    type_: type_0,
                    name: name0,
                } = value;
                *ptr.add(0).cast::<u8>() = (type_0.clone() as i32) as u8;
                let vec1 = (name0.into_bytes()).into_boxed_slice();
                let ptr1 = vec1.as_ptr().cast::<u8>();
                let len1 = vec1.len();
                ::core::mem::forget(vec1);
                *ptr.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len1;
                *ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr1
                    .cast_mut();
            }
        }
        unsafe fn dealloc_lists(ptr: *mut u8) {
            unsafe {
                let l0 = *ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l1 = *ptr
                    .add(2 * ::core::mem::size_of::<*const u8>())
                    .cast::<usize>();
                super::super::_rt::cabi_dealloc(l0, l1, 1);
            }
        }
        pub static VTABLE: wit_bindgen::rt::async_support::StreamVtable<
            super::super::wasi::filesystem::types::DirectoryEntry,
        > = wit_bindgen::rt::async_support::StreamVtable::<
            super::super::wasi::filesystem::types::DirectoryEntry,
        > {
            cancel_write,
            cancel_read,
            drop_writable,
            drop_readable,
            dealloc_lists: Some(dealloc_lists),
            layout: unsafe { ::std::alloc::Layout::from_size_align_unchecked(12, 4) },
            lift: Some(lift),
            lower: Some(lower),
            new,
            start_read,
            start_write,
        };
        impl super::StreamPayload
        for super::super::wasi::filesystem::types::DirectoryEntry {
            const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self> = &VTABLE;
        }
    }
    #[doc(hidden)]
    #[allow(unused_unsafe)]
    pub mod vtable2 {
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn cancel_write(_: u32) -> u32 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn cancel_read(_: u32) -> u32 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn drop_writable(_: u32) {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn drop_readable(_: u32) {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn new() -> u64 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn start_read(_: u32, _: *mut u8, _: usize) -> u32 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn start_write(_: u32, _: *const u8, _: usize) -> u32 {
            unreachable!()
        }
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-08-15")]
        unsafe extern "C" {
            #[link_name = "[stream-new-0][method]tcp-socket.listen"]
            fn new() -> u64;
            #[link_name = "[stream-cancel-write-0][method]tcp-socket.listen"]
            fn cancel_write(_: u32) -> u32;
            #[link_name = "[stream-cancel-read-0][method]tcp-socket.listen"]
            fn cancel_read(_: u32) -> u32;
            #[link_name = "[stream-drop-writable-0][method]tcp-socket.listen"]
            fn drop_writable(_: u32);
            #[link_name = "[stream-drop-readable-0][method]tcp-socket.listen"]
            fn drop_readable(_: u32);
            #[link_name = "[async-lower][stream-read-0][method]tcp-socket.listen"]
            fn start_read(_: u32, _: *mut u8, _: usize) -> u32;
            #[link_name = "[async-lower][stream-write-0][method]tcp-socket.listen"]
            fn start_write(_: u32, _: *const u8, _: usize) -> u32;
        }
        unsafe fn lift(ptr: *mut u8) -> super::super::wasi::sockets::types::TcpSocket {
            unsafe {
                let l0 = *ptr.add(0).cast::<i32>();
                super::super::wasi::sockets::types::TcpSocket::from_handle(l0 as u32)
            }
        }
        unsafe fn lower(
            value: super::super::wasi::sockets::types::TcpSocket,
            ptr: *mut u8,
        ) {
            unsafe {
                *ptr.add(0).cast::<i32>() = (value).take_handle() as i32;
            }
        }
        unsafe fn dealloc_lists(ptr: *mut u8) {
            unsafe {}
        }
        pub static VTABLE: wit_bindgen::rt::async_support::StreamVtable<
            super::super::wasi::sockets::types::TcpSocket,
        > = wit_bindgen::rt::async_support::StreamVtable::<
            super::super::wasi::sockets::types::TcpSocket,
        > {
            cancel_write,
            cancel_read,
            drop_writable,
            drop_readable,
            dealloc_lists: Some(dealloc_lists),
            layout: unsafe { ::std::alloc::Layout::from_size_align_unchecked(4, 4) },
            lift: Some(lift),
            lower: Some(lower),
            new,
            start_read,
            start_write,
        };
        impl super::StreamPayload for super::super::wasi::sockets::types::TcpSocket {
            const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self> = &VTABLE;
        }
    }
    /// Creates a new Component Model `stream` with the specified payload type.
    pub fn new<T: StreamPayload>() -> (
        wit_bindgen::rt::async_support::StreamWriter<T>,
        wit_bindgen::rt::async_support::StreamReader<T>,
    ) {
        unsafe { wit_bindgen::rt::async_support::stream_new::<T>(T::VTABLE) }
    }
}
#[rustfmt::skip]
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.46.0:wasi:cli@0.3.0-rc-2025-08-15:imports:encoded worldrust-wasip3-0.1.1+wasi-0.3.0-rc-2025-08-15-from-crates-io"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 7877] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xc7<\x01A\x02\x01A,\x01\
B\x0a\x01o\x02ss\x01p\0\x01@\0\0\x01\x04\0\x0fget-environment\x01\x02\x01ps\x01@\
\0\0\x03\x04\0\x0dget-arguments\x01\x04\x01ks\x01@\0\0\x05\x04\0\x0fget-initial-\
cwd\x01\x06\x03\0(wasi:cli/environment@0.3.0-rc-2025-08-15\x05\0\x01B\x03\x01j\0\
\0\x01@\x01\x06status\0\x01\0\x04\0\x04exit\x01\x01\x03\0!wasi:cli/exit@0.3.0-rc\
-2025-08-15\x05\x01\x01B\x03\x01f\x01}\x01@\0\0\0\x04\0\x09get-stdin\x01\x01\x03\
\0\"wasi:cli/stdin@0.3.0-rc-2025-08-15\x05\x02\x01B\x03\x01f\x01}\x01@\x01\x04da\
ta\0\x01\0\x04\0\x0aset-stdout\x01\x01\x03\0#wasi:cli/stdout@0.3.0-rc-2025-08-15\
\x05\x03\x01B\x03\x01f\x01}\x01@\x01\x04data\0\x01\0\x04\0\x0aset-stderr\x01\x01\
\x03\0#wasi:cli/stderr@0.3.0-rc-2025-08-15\x05\x04\x01B\x01\x04\0\x0eterminal-in\
put\x03\x01\x03\0+wasi:cli/terminal-input@0.3.0-rc-2025-08-15\x05\x05\x01B\x01\x04\
\0\x0fterminal-output\x03\x01\x03\0,wasi:cli/terminal-output@0.3.0-rc-2025-08-15\
\x05\x06\x02\x03\0\x05\x0eterminal-input\x01B\x06\x02\x03\x02\x01\x07\x04\0\x0et\
erminal-input\x03\0\0\x01i\x01\x01k\x02\x01@\0\0\x03\x04\0\x12get-terminal-stdin\
\x01\x04\x03\0+wasi:cli/terminal-stdin@0.3.0-rc-2025-08-15\x05\x08\x02\x03\0\x06\
\x0fterminal-output\x01B\x06\x02\x03\x02\x01\x09\x04\0\x0fterminal-output\x03\0\0\
\x01i\x01\x01k\x02\x01@\0\0\x03\x04\0\x13get-terminal-stdout\x01\x04\x03\0,wasi:\
cli/terminal-stdout@0.3.0-rc-2025-08-15\x05\x0a\x01B\x06\x02\x03\x02\x01\x09\x04\
\0\x0fterminal-output\x03\0\0\x01i\x01\x01k\x02\x01@\0\0\x03\x04\0\x13get-termin\
al-stderr\x01\x04\x03\0,wasi:cli/terminal-stderr@0.3.0-rc-2025-08-15\x05\x0b\x01\
B\x0c\x01w\x04\0\x07instant\x03\0\0\x01w\x04\0\x08duration\x03\0\x02\x01@\0\0\x01\
\x04\0\x03now\x01\x04\x01@\0\0\x03\x04\0\x0eget-resolution\x01\x05\x01@\x01\x04w\
hen\x01\x01\0\x04\0\x11[async]wait-until\x01\x06\x01@\x01\x08how-long\x03\x01\0\x04\
\0\x0f[async]wait-for\x01\x07\x03\0/wasi:clocks/monotonic-clock@0.3.0-rc-2025-08\
-15\x05\x0c\x01B\x05\x01r\x02\x07secondsw\x0bnanosecondsy\x04\0\x08datetime\x03\0\
\0\x01@\0\0\x01\x04\0\x03now\x01\x02\x04\0\x0eget-resolution\x01\x02\x03\0*wasi:\
clocks/wall-clock@0.3.0-rc-2025-08-15\x05\x0d\x02\x03\0\x0b\x08datetime\x01BY\x02\
\x03\x02\x01\x0e\x04\0\x08datetime\x03\0\0\x01w\x04\0\x08filesize\x03\0\x02\x01m\
\x08\x07unknown\x0cblock-device\x10character-device\x09directory\x04fifo\x0dsymb\
olic-link\x0cregular-file\x06socket\x04\0\x0fdescriptor-type\x03\0\x04\x01n\x06\x04\
read\x05write\x13file-integrity-sync\x13data-integrity-sync\x14requested-write-s\
ync\x10mutate-directory\x04\0\x10descriptor-flags\x03\0\x06\x01n\x01\x0esymlink-\
follow\x04\0\x0apath-flags\x03\0\x08\x01n\x04\x06create\x09directory\x09exclusiv\
e\x08truncate\x04\0\x0aopen-flags\x03\0\x0a\x01w\x04\0\x0alink-count\x03\0\x0c\x01\
k\x01\x01r\x06\x04type\x05\x0alink-count\x0d\x04size\x03\x15data-access-timestam\
p\x0e\x1bdata-modification-timestamp\x0e\x17status-change-timestamp\x0e\x04\0\x0f\
descriptor-stat\x03\0\x0f\x01q\x03\x09no-change\0\0\x03now\0\0\x09timestamp\x01\x01\
\0\x04\0\x0dnew-timestamp\x03\0\x11\x01r\x02\x04type\x05\x04names\x04\0\x0fdirec\
tory-entry\x03\0\x13\x01m$\x06access\x07already\x0ebad-descriptor\x04busy\x08dea\
dlock\x05quota\x05exist\x0efile-too-large\x15illegal-byte-sequence\x0bin-progres\
s\x0binterrupted\x07invalid\x02io\x0cis-directory\x04loop\x0etoo-many-links\x0cm\
essage-size\x0dname-too-long\x09no-device\x08no-entry\x07no-lock\x13insufficient\
-memory\x12insufficient-space\x0dnot-directory\x09not-empty\x0fnot-recoverable\x0b\
unsupported\x06no-tty\x0eno-such-device\x08overflow\x0dnot-permitted\x04pipe\x09\
read-only\x0cinvalid-seek\x0etext-file-busy\x0ccross-device\x04\0\x0aerror-code\x03\
\0\x15\x01m\x06\x06normal\x0asequential\x06random\x09will-need\x09dont-need\x08n\
o-reuse\x04\0\x06advice\x03\0\x17\x01r\x02\x05lowerw\x05upperw\x04\0\x13metadata\
-hash-value\x03\0\x19\x04\0\x0adescriptor\x03\x01\x01h\x1b\x01f\x01}\x01j\0\x01\x16\
\x01e\x01\x1e\x01o\x02\x1d\x1f\x01@\x02\x04self\x1c\x06offset\x03\0\x20\x04\0\"[\
method]descriptor.read-via-stream\x01!\x01@\x03\x04self\x1c\x04data\x1d\x06offse\
t\x03\0\x1e\x04\0)[async\x20method]descriptor.write-via-stream\x01\"\x01@\x02\x04\
self\x1c\x04data\x1d\0\x1e\x04\0*[async\x20method]descriptor.append-via-stream\x01\
#\x01@\x04\x04self\x1c\x06offset\x03\x06length\x03\x06advice\x18\0\x1e\x04\0\x1f\
[async\x20method]descriptor.advise\x01$\x01@\x01\x04self\x1c\0\x1e\x04\0\"[async\
\x20method]descriptor.sync-data\x01%\x01j\x01\x07\x01\x16\x01@\x01\x04self\x1c\0\
&\x04\0\"[async\x20method]descriptor.get-flags\x01'\x01j\x01\x05\x01\x16\x01@\x01\
\x04self\x1c\0(\x04\0![async\x20method]descriptor.get-type\x01)\x01@\x02\x04self\
\x1c\x04size\x03\0\x1e\x04\0![async\x20method]descriptor.set-size\x01*\x01@\x03\x04\
self\x1c\x15data-access-timestamp\x12\x1bdata-modification-timestamp\x12\0\x1e\x04\
\0\"[async\x20method]descriptor.set-times\x01+\x01f\x01\x14\x01o\x02,\x1f\x01@\x01\
\x04self\x1c\0-\x04\0'[async\x20method]descriptor.read-directory\x01.\x04\0\x1d[\
async\x20method]descriptor.sync\x01%\x01@\x02\x04self\x1c\x04paths\0\x1e\x04\0,[\
async\x20method]descriptor.create-directory-at\x01/\x01j\x01\x10\x01\x16\x01@\x01\
\x04self\x1c\00\x04\0\x1d[async\x20method]descriptor.stat\x011\x01@\x03\x04self\x1c\
\x0apath-flags\x09\x04paths\00\x04\0\x20[async\x20method]descriptor.stat-at\x012\
\x01@\x05\x04self\x1c\x0apath-flags\x09\x04paths\x15data-access-timestamp\x12\x1b\
data-modification-timestamp\x12\0\x1e\x04\0%[async\x20method]descriptor.set-time\
s-at\x013\x01@\x05\x04self\x1c\x0eold-path-flags\x09\x08old-paths\x0enew-descrip\
tor\x1c\x08new-paths\0\x1e\x04\0\x20[async\x20method]descriptor.link-at\x014\x01\
i\x1b\x01j\x015\x01\x16\x01@\x05\x04self\x1c\x0apath-flags\x09\x04paths\x0aopen-\
flags\x0b\x05flags\x07\06\x04\0\x20[async\x20method]descriptor.open-at\x017\x01j\
\x01s\x01\x16\x01@\x02\x04self\x1c\x04paths\08\x04\0$[async\x20method]descriptor\
.readlink-at\x019\x04\0,[async\x20method]descriptor.remove-directory-at\x01/\x01\
@\x04\x04self\x1c\x08old-paths\x0enew-descriptor\x1c\x08new-paths\0\x1e\x04\0\"[\
async\x20method]descriptor.rename-at\x01:\x01@\x03\x04self\x1c\x08old-paths\x08n\
ew-paths\0\x1e\x04\0#[async\x20method]descriptor.symlink-at\x01;\x04\0'[async\x20\
method]descriptor.unlink-file-at\x01/\x01@\x02\x04self\x1c\x05other\x1c\0\x7f\x04\
\0'[async\x20method]descriptor.is-same-object\x01<\x01j\x01\x1a\x01\x16\x01@\x01\
\x04self\x1c\0=\x04\0&[async\x20method]descriptor.metadata-hash\x01>\x01@\x03\x04\
self\x1c\x0apath-flags\x09\x04paths\0=\x04\0)[async\x20method]descriptor.metadat\
a-hash-at\x01?\x03\0)wasi:filesystem/types@0.3.0-rc-2025-08-15\x05\x0f\x02\x03\0\
\x0c\x0adescriptor\x01B\x07\x02\x03\x02\x01\x10\x04\0\x0adescriptor\x03\0\0\x01i\
\x01\x01o\x02\x02s\x01p\x03\x01@\0\0\x04\x04\0\x0fget-directories\x01\x05\x03\0,\
wasi:filesystem/preopens@0.3.0-rc-2025-08-15\x05\x11\x02\x03\0\x0a\x08duration\x01\
Bq\x02\x03\x02\x01\x12\x04\0\x08duration\x03\0\0\x01m\x0e\x07unknown\x0daccess-d\
enied\x0dnot-supported\x10invalid-argument\x0dout-of-memory\x07timeout\x0dinvali\
d-state\x14address-not-bindable\x0eaddress-in-use\x12remote-unreachable\x12conne\
ction-refused\x10connection-reset\x12connection-aborted\x12datagram-too-large\x04\
\0\x0aerror-code\x03\0\x02\x01m\x02\x04ipv4\x04ipv6\x04\0\x11ip-address-family\x03\
\0\x04\x01o\x04}}}}\x04\0\x0cipv4-address\x03\0\x06\x01o\x08{{{{{{{{\x04\0\x0cip\
v6-address\x03\0\x08\x01q\x02\x04ipv4\x01\x07\0\x04ipv6\x01\x09\0\x04\0\x0aip-ad\
dress\x03\0\x0a\x01r\x02\x04port{\x07address\x07\x04\0\x13ipv4-socket-address\x03\
\0\x0c\x01r\x04\x04port{\x09flow-infoy\x07address\x09\x08scope-idy\x04\0\x13ipv6\
-socket-address\x03\0\x0e\x01q\x02\x04ipv4\x01\x0d\0\x04ipv6\x01\x0f\0\x04\0\x11\
ip-socket-address\x03\0\x10\x04\0\x0atcp-socket\x03\x01\x04\0\x0audp-socket\x03\x01\
\x01i\x12\x01j\x01\x14\x01\x03\x01@\x01\x0eaddress-family\x05\0\x15\x04\0\x19[st\
atic]tcp-socket.create\x01\x16\x01h\x12\x01j\0\x01\x03\x01@\x02\x04self\x17\x0dl\
ocal-address\x11\0\x18\x04\0\x17[method]tcp-socket.bind\x01\x19\x01@\x02\x04self\
\x17\x0eremote-address\x11\0\x18\x04\0\x20[async\x20method]tcp-socket.connect\x01\
\x1a\x01f\x01\x14\x01j\x01\x1b\x01\x03\x01@\x01\x04self\x17\0\x1c\x04\0\x19[meth\
od]tcp-socket.listen\x01\x1d\x01f\x01}\x01@\x02\x04self\x17\x04data\x1e\0\x18\x04\
\0\x1d[async\x20method]tcp-socket.send\x01\x1f\x01e\x01\x18\x01o\x02\x1e\x20\x01\
@\x01\x04self\x17\0!\x04\0\x1a[method]tcp-socket.receive\x01\"\x01j\x01\x11\x01\x03\
\x01@\x01\x04self\x17\0#\x04\0$[method]tcp-socket.get-local-address\x01$\x04\0%[\
method]tcp-socket.get-remote-address\x01$\x01@\x01\x04self\x17\0\x7f\x04\0#[meth\
od]tcp-socket.get-is-listening\x01%\x01@\x01\x04self\x17\0\x05\x04\0%[method]tcp\
-socket.get-address-family\x01&\x01@\x02\x04self\x17\x05valuew\0\x18\x04\0*[meth\
od]tcp-socket.set-listen-backlog-size\x01'\x01j\x01\x7f\x01\x03\x01@\x01\x04self\
\x17\0(\x04\0)[method]tcp-socket.get-keep-alive-enabled\x01)\x01@\x02\x04self\x17\
\x05value\x7f\0\x18\x04\0)[method]tcp-socket.set-keep-alive-enabled\x01*\x01j\x01\
\x01\x01\x03\x01@\x01\x04self\x17\0+\x04\0+[method]tcp-socket.get-keep-alive-idl\
e-time\x01,\x01@\x02\x04self\x17\x05value\x01\0\x18\x04\0+[method]tcp-socket.set\
-keep-alive-idle-time\x01-\x04\0*[method]tcp-socket.get-keep-alive-interval\x01,\
\x04\0*[method]tcp-socket.set-keep-alive-interval\x01-\x01j\x01y\x01\x03\x01@\x01\
\x04self\x17\0.\x04\0'[method]tcp-socket.get-keep-alive-count\x01/\x01@\x02\x04s\
elf\x17\x05valuey\0\x18\x04\0'[method]tcp-socket.set-keep-alive-count\x010\x01j\x01\
}\x01\x03\x01@\x01\x04self\x17\01\x04\0\x20[method]tcp-socket.get-hop-limit\x012\
\x01@\x02\x04self\x17\x05value}\0\x18\x04\0\x20[method]tcp-socket.set-hop-limit\x01\
3\x01j\x01w\x01\x03\x01@\x01\x04self\x17\04\x04\0*[method]tcp-socket.get-receive\
-buffer-size\x015\x04\0*[method]tcp-socket.set-receive-buffer-size\x01'\x04\0'[m\
ethod]tcp-socket.get-send-buffer-size\x015\x04\0'[method]tcp-socket.set-send-buf\
fer-size\x01'\x01i\x13\x01j\x016\x01\x03\x01@\x01\x0eaddress-family\x05\07\x04\0\
\x19[static]udp-socket.create\x018\x01h\x13\x01@\x02\x04self9\x0dlocal-address\x11\
\0\x18\x04\0\x17[method]udp-socket.bind\x01:\x01@\x02\x04self9\x0eremote-address\
\x11\0\x18\x04\0\x1a[method]udp-socket.connect\x01;\x01@\x01\x04self9\0\x18\x04\0\
\x1d[method]udp-socket.disconnect\x01<\x01p}\x01k\x11\x01@\x03\x04self9\x04data=\
\x0eremote-address>\0\x18\x04\0\x1d[async\x20method]udp-socket.send\x01?\x01o\x02\
=\x11\x01j\x01\xc0\0\x01\x03\x01@\x01\x04self9\0\xc1\0\x04\0\x20[async\x20method\
]udp-socket.receive\x01B\x01@\x01\x04self9\0#\x04\0$[method]udp-socket.get-local\
-address\x01C\x04\0%[method]udp-socket.get-remote-address\x01C\x01@\x01\x04self9\
\0\x05\x04\0%[method]udp-socket.get-address-family\x01D\x01@\x01\x04self9\01\x04\
\0([method]udp-socket.get-unicast-hop-limit\x01E\x01@\x02\x04self9\x05value}\0\x18\
\x04\0([method]udp-socket.set-unicast-hop-limit\x01F\x01@\x01\x04self9\04\x04\0*\
[method]udp-socket.get-receive-buffer-size\x01G\x01@\x02\x04self9\x05valuew\0\x18\
\x04\0*[method]udp-socket.set-receive-buffer-size\x01H\x04\0'[method]udp-socket.\
get-send-buffer-size\x01G\x04\0'[method]udp-socket.set-send-buffer-size\x01H\x03\
\0&wasi:sockets/types@0.3.0-rc-2025-08-15\x05\x13\x02\x03\0\x0e\x0aip-address\x01\
B\x08\x02\x03\x02\x01\x14\x04\0\x0aip-address\x03\0\0\x01m\x06\x07unknown\x0dacc\
ess-denied\x10invalid-argument\x11name-unresolvable\x1atemporary-resolver-failur\
e\x1apermanent-resolver-failure\x04\0\x0aerror-code\x03\0\x02\x01p\x01\x01j\x01\x04\
\x01\x03\x01@\x01\x04names\0\x05\x04\0\x18[async]resolve-addresses\x01\x06\x03\0\
/wasi:sockets/ip-name-lookup@0.3.0-rc-2025-08-15\x05\x15\x01B\x05\x01p}\x01@\x01\
\x03lenw\0\0\x04\0\x10get-random-bytes\x01\x01\x01@\0\0w\x04\0\x0eget-random-u64\
\x01\x02\x03\0&wasi:random/random@0.3.0-rc-2025-08-15\x05\x16\x01B\x05\x01p}\x01\
@\x01\x03lenw\0\0\x04\0\x19get-insecure-random-bytes\x01\x01\x01@\0\0w\x04\0\x17\
get-insecure-random-u64\x01\x02\x03\0(wasi:random/insecure@0.3.0-rc-2025-08-15\x05\
\x17\x01B\x03\x01o\x02ww\x01@\0\0\0\x04\0\x11get-insecure-seed\x01\x01\x03\0-was\
i:random/insecure-seed@0.3.0-rc-2025-08-15\x05\x18\x04\0$wasi:cli/imports@0.3.0-\
rc-2025-08-15\x04\0\x0b\x0d\x01\0\x07imports\x03\0\0\0G\x09producers\x01\x0cproc\
essed-by\x02\x0dwit-component\x070.239.0\x10wit-bindgen-rust\x060.46.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen::rt::maybe_link_cabi_realloc();
}
